<!-- $Id: zoom.xml,v 1.17 2002-01-28 09:27:48 adam Exp $ -->
 <chapter id="zoom"><title>Building clients with ZOOM</title>
  
  <para>
    &zoom; is an acronym for 'Z39.50 Object-Orientation Model' and is
   an initiative started by Mike Taylor (Mike is from the UK, which
   explains the peculiar name of the model). The goal of &zoom; is to
   provide a common Z39.50 client API not bound to a particular
   programming language or toolkit.
  </para>
  <para>
   The lack of a simple Z39.50 client API for &yaz; has become more
   and more apparent over time. So when the first &zoom; specification
   became available,
   an implementation for &yaz; was quickly developed. For the first time, it is
   now as easy (or easier!) to develop clients than servers with &yaz;. This
   chapter describes the &zoom; C binding. Before going futher, please
   reconsider whether C is the right programming language for the job.
   There are other language bindings available for &yaz;, and still
   more
   are in active development. See the
   <ulink url="http://zoom.z3950.org/">ZOOM website</ulink> for
   more information.
  </para>

  <para>
   In order to fully understand this chapter you should read and
   try the example programs <literal>zoomtst1.c</literal>,
   <literal>zoomtst2.c</literal>, .. in the <literal>zoom</literal>
   directory.
  </para>

  <para>
   The C language misses features found in object oriented languages
   such as C++, Java, etc. For example, you'll have to manually,
   destroy all objects you create, even though you may think of them as
   temporary. Most objects has a <literal>_create</literal> - and a
   <literal>_destroy</literal> variant.
   All objects are in fact pointers to internal stuff, but you don't see
   that because of typedefs. All destroy methods should gracefully ignore a
   <literal>NULL</literal> pointer.
  </para>
  <para>
   In each of the sections below you'll find a sub section called
   protocol behavior, that descries how the API maps to the Z39.50
   protocol.
  </para>
  <sect1 id="zoom.connections"><title>Connections</title>
   
   <para>The Connection object is a session with a target.
   </para>
   <synopsis>
   #include &lt;yaz/zoom.h>
    
   ZOOM_connection ZOOM_connection_new (const char *host, int portnum);
    
   ZOOM_connection ZOOM_connection_create (ZOOM_options options);

   void ZOOM_connection_connect(ZOOM_connection c, const char *host,
                                 int portnum);
   void ZOOM_connection_destroy (ZOOM_connection c);
   </synopsis>
   <para>
    Connection objects are created with either function
    <function>ZOOM_connection_new</function> or 
    <function>ZOOM_connection_create</function>.
    The former creates and automatically attempts to establish a network
    connection with the target. The latter doesn't establish
    a connection immediately, thus allowing you to specify options
    before establishing network connection using the function
    <function>ZOOM_connection_connect</function>. 
    If the portnumber, <literal>portnum</literal>, is zero, the
    <literal>host</literal> is consulted for a port specification.
    If no port is given, 210 is used. A colon denotes the beginning of
    a port number in the host string. If the host string includes a
    slash, the following part specifies a database for the connection.
   </para>
   <para>
    Connection objects should be destroyed using the function
    <function>ZOOM_connection_destroy</function>.
   </para>
   <synopsis>
    void ZOOM_connection_option_set (ZOOM_connection c,
                                     const char *key,
                                     const char *val);

    const char *ZOOM_connection_option_get (ZOOM_connection c,
                                            const char *key);
   </synopsis>
   <para>
    The <function>ZOOM_connection_option_set</function> allows you to
    set an option given by <parameter>key</parameter> to the value
    <parameter>value</parameter> for the connection.
     Function <function>ZOOM_connection_option_get</function> returns
    the value for an option given by <parameter>key</parameter>.
   </para>
   <table frame="sides" colsep="1"><title>ZOOM Connection Options</title>
    <tgroup cols="3">
     <colspec colwidth="4*" colname="name"></colspec>
     <colspec colwidth="7*" colname="description"></colspec>
     <colspec colwidth="3*" colname="default"></colspec>
     <thead>
      <row>
       <entry>Option</entry>
       <entry>Description</entry>
       <entry>Default</entry>
      </row>
     </thead>
     <tbody>
      <row><entry>
        implementationName</entry><entry>Name of Your client
       </entry><entry>none</entry></row>
      <row><entry>
        user</entry><entry>Authentication user name
       </entry><entry>none</entry></row>
      <row><entry>
        group</entry><entry>Authentication group name
       </entry><entry>none</entry></row>
      <row><entry>
        pass</entry><entry>Authentication password
      </entry><entry>none</entry></row>
      <row><entry>
        host</entry><entry>Target host. This setting is "read-only".
        It's automatically set internally when connecting to a target.
       </entry><entry>none</entry></row>
      <row><entry>
        proxy</entry><entry>Proxy host
       </entry><entry>none</entry></row>
      <row><entry>
        async</entry><entry>If true (1) the connection operates in 
        asynchronous operation which means that all calls are non-blocking
        except
        <link linkend="zoom.events"><function>ZOOM_event</function></link>.
       </entry><entry>0</entry></row>
      <row><entry>
        maximumRecordSize</entry><entry> Maximum size of single record.
       </entry><entry>1 MB</entry></row>
      <row><entry>
        preferredMessageSize</entry><entry> Maximum size of multiple records.
       </entry><entry>1 MB</entry></row>
     </tbody>
    </tgroup>
   </table>
   <synopsis>
     int ZOOM_connection_error (ZOOM_connection c, const char **cp,
                                 const char **addinfo);
   </synopsis>
   <para>
    Use <function>ZOOM_connection_error</function> to check for
    errors for the last operation(s) performed. The function returns
    zero if no errors occurred; non-zero otherwise indicating the error.
    Pointers <parameter>cp</parameter> and <parameter>addinfo</parameter>
    holds messages for the error and additional-info if passed as
    non-<literal>NULL</literal>.
   </para>
   <sect2><title>Protocol behavior</title>
    <para>
     The calls <function>ZOOM_connection_new</function> and
     <function>ZOOM_connection_connect</function> establises a TCP/IP
      connection and sends an Initialize Request to the target if
      possible. In addition, the calls waits for an Initialize Response
      from the target and the result is inspected (OK or rejected).
    </para>
    <para>
     If <literal>proxy</literal> is set then the client will establish
     a TCP/IP connection with the peer as specified by the
     <literal>proxy</literal> host and the hostname as part of the
     connect calls will be set as part of the Initialize Request.
     The proxy server will then "forward" the PDU's transparently
     to the target behind the proxy.
    </para>
    <para>
     For the authentication parameters, if option <literal>user</literal>
     is set and both options <literal>group</literal> and
     <literal>pass</literal> are unset, then Open style
     authentication is used (Version 2/3) in which case the username
     is usually followed by a slash, then by a password.
     If either <literal>group</literal>
     or <literal>pass</literal> is set then idPass authentication
     (Version 3 only) is used. If none of the options are set, no
     authentication parameters are set as part of the Initialize Request
     (obviously).
    </para>
    <para>
     When option <literal>async</literal> is 1, it really means that
     all network operations are postponed (and queued) until the
     function <literal>ZOOM_event</literal> is invoked. When doing so
     it doesn't make sense to check for errors after
     <literal>ZOOM_connection_new</literal> is called since that
     operation "connecting - and init" is still incomplete and the
     API cannot tell the outcome (yet).
    </para>
    </sect2>
  </sect1>
  <sect1 id="zoom.query"><title>Queries</title>
   <para>
    Query objects represents queries.
   </para>
   <synopsis>
     ZOOM_query ZOOM_query_create(void);

     void ZOOM_query_destroy(ZOOM_query q);

     int ZOOM_query_prefix(ZOOM_query q, const char *str);

     int ZOOM_query_sortby(ZOOM_query q, const char *criteria);
   </synopsis>
   <para>
    Create query objects using <function>ZOOM_query_create</function>
    and destroy them by calling <function>ZOOM_query_destroy</function>.
    RPN-queries can be specified in <link linkend="PQF">PQF</link>
    notation by using the
    function <function>ZOOM_query_prefix</function>. More
    query types will be added later, such as
    <link linkend="CCL">CCL</link> to RPN-mapping, native CCL query,
    etc. In addition to a search, a sort criteria may be set. Function
    <function>ZOOM_query_sortby</function> specifies a 
    sort criteria using the same string notation for sort as offered by
    the <link linkend="sortspec">YAZ client</link>.
   </para>
   <sect2><title>Protocol behavior</title>
    <para>
     The query object is just an interface for the member Query
     in the SearchRequest. The sortby-function is an interface to the
     sortSequence member of the SortRequest.
    </para>
   </sect2>
  </sect1>
  <sect1 id="zoom.resultsets"><title>Result sets</title>
   <para>
    The result set object is a container for records returned from
    a target.
   </para>
   <synopsis>
     ZOOM_resultset ZOOM_connection_search(ZOOM_connection,
                                           ZOOM_query q);

     ZOOM_resultset ZOOM_connection_search_pqf(ZOOM_connection c,
                                               const char *q);

     void ZOOM_resultset_destroy(ZOOM_resultset r);
   </synopsis>
   <para>
    Function <function>ZOOM_connection_search</function> creates
     a result set given a connection and query.
    Destroy a result set by calling
    <function>ZOOM_resultset_destroy</function>.
    Simple clients may using PQF only may use function
    <function>ZOOM_connection_search_pqf</function> in which case
    creating query objects is not necessary.
   </para>
   <synopsis>
     void ZOOM_resultset_option_set (ZOOM_resultset r,
                                      const char *key,
                                      const char *val);

     const char *ZOOM_resultset_option_get (ZOOM_resultset r,
                                             const char *key);

     size_t ZOOM_resultset_size (ZOOM_resultset r);
   </synopsis>
   <para>
    Functions <function>ZOOM_resultset_options_set</function> and
    <function>ZOOM_resultset_get</function> sets and gets an option
    for a result set similar to <function>ZOOM_connection_option_get</function>
    and <function>ZOOM_connection_option_set</function>.
   </para>
   <para>
    The number of hits also called result-count is returned by
    function <function>ZOOM_resultset_size</function>.
   </para>
   <table frame="top"><title>ZOOM Result set Options</title>
    <tgroup cols="3">
     <colspec colwidth="4*" colname="name"></colspec>
     <colspec colwidth="7*" colname="description"></colspec>
     <colspec colwidth="2*" colname="default"></colspec>
     <thead>
      <row>
       <entry>Option</entry>
       <entry>Description</entry>
       <entry>Default</entry>
      </row>
     </thead>
     <tbody>
      <row><entry>
        piggyback</entry><entry>True (1) if piggyback should be
        used in searches; false (0) if not.
       </entry><entry>1</entry></row>
      <row><entry>
        start</entry><entry>Offset of first record to be 
        retrieved from target. First record has offset 0 unlike the
        protocol specifications where first record has position 1.
       </entry><entry>0</entry></row>
      <row><entry>
        count</entry><entry>Number of records to be retrieved.
       </entry><entry>0</entry></row>
      <row><entry>
        elementSetName</entry><entry>Element-Set name of records. 
        Most targets should honor element set name <literal>B</literal>
        and <literal>F</literal> for brief and full respectively.
       </entry><entry>none</entry></row>
      <row><entry>
        preferredRecordSyntax</entry><entry>Preferred Syntax, such as
        <literal>USMARC</literal>, <literal>SUTRS</literal>, etc.
       </entry><entry>none</entry></row>
      <row><entry>
        schema</entry><entry>Schema for retrieval, such as
        <literal>Gils-schema</literal>, <literal>Geo-schema</literal>, etc.
       </entry><entry>none</entry></row>
      <row><entry>
        smallSetUpperBound</entry><entry>If hits is less than or equal to this
        value, then target will return all records using small element set name
       </entry><entry>0</entry></row>
      <row><entry>
        largeSetLowerBound</entry><entry>If hits is greator than this
        value, the target will return no records.
       </entry><entry>1</entry></row>
      <row><entry>
        mediumSetPresentNumber</entry><entry>This value represents
        the number of records to be returned as part of a search when when
        hits is less than or equal to large set lower bound and if hits
        is greator than small set upper bound.
       </entry><entry>0</entry></row>
      <row><entry>
        smallSetElementSetName</entry><entry>
        The element set name to be used for small result sets.
       </entry><entry>none</entry></row>
      <row><entry>
        mediumSetElementSetName</entry><entry>
        The element set name to be for medium-sized result sets.
       </entry><entry>none</entry></row>
      <row><entry>
        databaseName</entry><entry>One or more database names
        separated by character plus (<literal>+</literal>).
       </entry><entry>Default</entry></row>
      <row><entry>
        setname</entry><entry>Name of Result Set (Result Set ID).
        If this option isn't set, the ZOOM module will automatically
        allocate a result set name.
       </entry><entry>default</entry></row>
     </tbody>
    </tgroup>
   </table>
   <sect2>
    <title>Protocol behavior</title>
    <para>
     The creation of a result set involves at least a SearchRequest
     - SearchResponse protocol handshake. Following that, if a sort
     critieria was specified as part of the query, a sortRequest -
     SortResponse handshake takes place. Note that it is necessary to
     perform sorting before any retrieval takes place, so no records will
     be returned from the target as part of the SearchResponse because these
     would be unsorted. Hence, piggyback is disabled when sort critieria
     is set. Following Search - and a Possible sort, Retrieval takes
     place - as one or more Present Requests - Present Response being
     transferred.
     </para>
    <para>
     The API allows for two different modes for retrieval. A high level
     mode which is somewhat more powerful and a low level one.
     The low level is "enabled" when the settings
     <literal>smallSetUpperBound</literal>,
     <literal>mediumSetPresentNumber</literal> and
     <literal>largeSetLowerBound</literal> are set. The low level mode
     thus allows you to precisely set how records are returned as part
     of a search response as offered by the Z39.50 protocol.
     Since the client may be retrieving records as part of the
     search response, this mode doesn't work well if sorting is used.
     </para>
    <para>
     The high-level mode allows you to fetch a range of records from
     the result set with a given start offset. When you use this mode
     the client will automatically use piggyback if that is possible
     with the target and perform one or more present requests as needed.
     Even if the target returns fewer records as part of a present response
     because of a record size limit, etc. the client will repeat sending
     present requests. As an example, if option <literal>start</literal>
     is 0 (default) and <literal>count</literal> is 4, and
     <literal>piggyback</literal> is 1 (default) and no sorting critieria
     is specified, then the client will attempt to retrieve the 4
     records as part the search response (using piggyback). On the other
     hand, if either <literal>start</literal> is positive or if
     a sorting criteria is set, or if <literal>piggyback</literal>
     is 0, then the client will not perform piggyback but send Present
     Requests instead.
    </para>
    <para>
     If either of the options <literal>mediumSetElementSetName</literal> and
     <literal>smallSetElementSetName</literal> are unset, the value
     of option <literal>elementSetName</literal> is used for piggyback
     searches. This means that for the high-level mode you only have
     to specify one elementSetName option rather than three.
     </para>
   </sect2>
  </sect1>
  <sect1 id="zoom.records"><title>Records</title>
   <para>
    A record object is a retrival record on the client side -
    created from result sets.
   </para>
   <synopsis>
     void ZOOM_resultset_records (ZOOM_resultset r,
                                  ZOOM_record *recs,
                                  size_t start, size_t count);
     ZOOM_record ZOOM_resultset_record (ZOOM_resultset s, size_t pos);

     const char *ZOOM_record_get (ZOOM_record rec, const char *type,
                                  size_t *len);

     ZOOM_record ZOOM_record_clone (ZOOM_record rec);

     void ZOOM_record_destroy (ZOOM_record rec);
   </synopsis>
   <para>
    References to temporary records are returned by functions 
    <function>ZOOM_resultset_records</function> or
    <function>ZOOM_resultset_record</function>.
    </para>
   <para>
    If a persistent reference to a record is desired
    <function>ZOOM_record_clone</function> should be used.
    It returns a record reference that should be destroyed
    by a call to <function>ZOOM_record_destroy</function>.
   </para>
   <para>
    A single record is returned by function
    <function>ZOOM_resultset_record</function> that takes a 
    position as argument. First record has position zero.
    If no record could be obtained <literal>NULL</literal> is returned.
   </para>
   <para>
    Function <function>ZOOM_resultset_records</function> retrieves
    a number of records from a result set. Parameter <literal>start</literal>
    and <literal>count</literal> specifies the range of records to
    be returned. Upon completion array
    <literal>recs[0], ..recs[count-1]</literal>
    holds record objects for the records. The array of records
     <literal>recs</literal> should be allocated prior the call
    <function>ZOOM_resultset_records</function>. Note that for those
    records that couldn't be retrieved from the target
    <literal>recs[ ..]</literal> is set to <literal>NULL</literal>.
   </para>
   <para id="zoom.record.get">
    In order to extract information about a single record,
    <function>ZOOM_record_get</function> is provided. The
    function returns a pointer to certain record information. The
    nature (type) of the pointer depends on the parameter,
    <function>type</function>.
    In addition, for certain types, the length
    <literal>len</literal> passed will be set to the size in bytes of
    the returned information.
    <variablelist>
     <varlistentry><term><literal>database</literal></term>
      <listitem><para>Database of record is returned
        as a C null-terminated string. Return type
        <literal>const char *</literal>. 
       </para></listitem>
      </varlistentry>
     <varlistentry><term><literal>syntax</literal></term>
      <listitem><para>The transfer syntax (OID) of the record is returned
        as a C null-terminated string. Return type is
        <literal>const char *</literal>. 
       </para></listitem>
      </varlistentry>
     <varlistentry><term><literal>render</literal></term>
      <listitem><para>The record is returned in a display friendly
        format. Upon completion buffer is returned
        (type <literal>const char *</literal>) and length is stored in
        <literal>*len</literal>.
       </para></listitem>
      </varlistentry>
     <varlistentry><term><literal>raw</literal></term>
      <listitem><para>The record is returned in the internal
        YAZ specific format. For GRS-1, Explain, and others, t
        he raw data is returned as type 
        <literal>Z_External *</literal> which is just the type for
        the member <literal>retrievalRecord</literal> in
        type <literal>NamePlusRecord</literal>.
        For SUTRS and octet aligned record (including all MARCs) the
        octet buffer is returned and the length of the buffer.
       </para></listitem>
      </varlistentry>
    </variablelist>
   </para>
   <sect2><title>Protocol behavior</title>
    <para>
     The functions <function>ZOOM_resultset_record</function> and
     <function>ZOOM_resultset_records</function> inspects the client-side
     record cache. Records not found in cache are fetched using
     Present.
     The functions may block (and perform network I/O)  - even though option
     <literal>async</literal> is 1, because they return records objects.
     (and there's no way to return records objects without retrieving them!).
     </para>
    <para>
     There is a trick, however, in the usage of function
     <function>ZOOM_resultset_records</function> that allows for
     delayed retrieval (and makes it non-blocking). By passing
     a null pointer for <parameter>recs</parameter> you're indicating
     you're not interested in getting records objects
     <emphasis>now</emphasis>.
    </para>
   </sect2>
  </sect1>
  <sect1 id="zoom.scan"><title>Scan</title>
   <para>
    This section describes an interface for Scan. Scan is not an
    official part of the ZOOM model yet. The result of a scan operation
    is the <literal>ZOOM_scanset</literal> which is a set of terms
    returned by a target.
   </para>
   <synopsis>
    ZOOM_scanset ZOOM_connection_scan (ZOOM_connection c,
                                       const char *startterm);

    size_t ZOOM_scanset_size(ZOOM_scanset scan);

    const char * ZOOM_scanset_term(ZOOM_scanset scan, size_t pos,
                                   int *occ, size_t *len);


    void ZOOM_scanset_destroy (ZOOM_scanset scan);

    const char *ZOOM_scanset_option_get (ZOOM_scanset scan,
                                         const char *key);

    void ZOOM_scanset_option_set (ZOOM_scanset scan, const char *key,
                                  const char *val);
    </synopsis>
   <para>
    The scan set is created by function
    <function>ZOOM_connection_scan</function> which performs a scan
    operation on the connection and start term given.
    If the operation was successful, the size of the scan set can be
    retrived by a call to <function>ZOOM_scanset_size</function>.
    Like result sets, the items are numbered 0,..size-1.
    To obtain information about a particular scan term, call function
    <function>ZOOM_scanset_term</function>. This function takes
    a scan set offset <literal>pos</literal> and returns a pointer
    to an actual term or <literal>NULL</literal> if non-present.
    If present, the <literal>occ</literal> and <literal>len</literal> 
    are set to the number of occurrences and the length
    of the actual term respectively.
    A scan set may be freed by a call to function
    <function>ZOOM_scanset_destroy</function>.
    Functions <function>ZOOM_scanset_option_get</function> and
    <function>ZOOM_scanset_option_set</function> retrieves and sets
    an option respectively.
   </para>
   
   <table frame="top"><title>ZOOM Scan Set Options</title>
    <tgroup cols="3">
     <colspec colwidth="4*" colname="name"></colspec>
     <colspec colwidth="7*" colname="description"></colspec>
     <colspec colwidth="2*" colname="default"></colspec>
     <thead>
      <row>
       <entry>Option</entry>
       <entry>Description</entry>
       <entry>Default</entry>
      </row>
     </thead>
     <tbody>
      <row><entry>
        number</entry><entry>Number of Scan Terms requested in next scan.
        After scan it holds the actual number of terms returend.
       </entry><entry>10</entry></row>
      <row><entry>
        position</entry><entry>Preferred Position of term in response
        in next scan; actual position after completion of scan.
       </entry><entry>1</entry></row>
      <row><entry>
        stepSize</entry><entry>Step Size
       </entry><entry>0</entry></row>
      <row><entry>
        scanStatus</entry><entry>An integer indicating the Scan Status
        of last scan.
       </entry><entry>0</entry></row>
     </tbody>
    </tgroup>
   </table>
   
  </sect1>
  <sect1 id="zoom.options"><title>Options</title>
   <para>
    Most &zoom; objects provide a way to specify options to change behavior.
    From an implementation point of view a set of options is just like
    an associative array / hash array, etc.
   </para>
   <synopsis>
     ZOOM_options ZOOM_options_create (void);

     ZOOM_options ZOOM_options_create_with_parent (ZOOM_options parent);

     void ZOOM_options_destroy (ZOOM_options opt);
   </synopsis>
   <synopsis>
     const char *ZOOM_options_get (ZOOM_options opt, const char *name);

     void ZOOM_options_set (ZOOM_options opt, const char *name,
                            const char *v);
   </synopsis>
   <synopsis>
     typedef const char *(*ZOOM_options_callback)
                                     (void *handle, const char *name);

     ZOOM_options_callback
             ZOOM_options_set_callback (ZOOM_options opt,
                                        ZOOM_options_callback c,
                                        void *handle);
   </synopsis>
  </sect1>
  <sect1 id="zoom.events"><title>Events</title>
   <para>
    If you're developing non-blocking applications, you have to deal 
    with events.
   </para>
   <synopsis>
    int ZOOM_event (int no, ZOOM_connection *cs);
   </synopsis>
   <para>
    The <function>ZOOM_event</function> executes pending events for
    a number of connections. Supply the number of connections in
    <literal>no</literal> and an array of connections in
    <literal>cs</literal> (<literal>cs[0] ... cs[no-1]</literal>).
    A pending event could be a sending a search, receiving a response,
    etc.
    When an event has occured for one of the connections, this function
    returns a positive integer <literal>n</literal> denoting that an event
    occurred for connection <literal>cs[n-1]</literal>.
    When no events are pending for the connections, a value of zero is
    returned.
    To ensure that all outstanding requests are performed call this function
    repeatedly until zero is returned.
   </para>
  </sect1>
 </chapter>
 
 <!-- Keep this comment at the end of the file
 Local variables:
 mode: sgml
 sgml-omittag:t
 sgml-shorttag:t
 sgml-minimize-attributes:nil
 sgml-always-quote-attributes:t
 sgml-indent-step:1
 sgml-indent-data:t
 sgml-parent-document: "yaz.xml"
 sgml-local-catalogs: nil
 sgml-namecase-general:t
 End:
 -->
 
