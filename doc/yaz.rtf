{\rtf1\ansi\ansicpg1252\uc1 \deff0\deflang1033\deflangfe1033{\fonttbl{\f0\froman\fcharset0\fprq2{\*\panose 02020603050405020304}Times New Roman;}{\f1\fswiss\fcharset0\fprq2{\*\panose 020b0604020202020204}Arial;}
{\f2\fmodern\fcharset0\fprq1{\*\panose 02070309020205020404}Courier New;}{\f3\froman\fcharset2\fprq2{\*\panose 05050102010706020507}Symbol;}{\f4\froman\fcharset0\fprq2{\*\panose 00000000000000000000}Times;}
{\f5\fswiss\fcharset0\fprq2{\*\panose 00000000000000000000}Helvetica;}{\f6\froman\fcharset0\fprq2{\*\panose 00000000000000000000}Courier;}{\f7\fswiss\fcharset0\fprq2{\*\panose 00000000000000000000}Geneva;}
{\f8\froman\fcharset0\fprq2{\*\panose 00000000000000000000}Tms Rmn;}{\f9\fswiss\fcharset0\fprq2{\*\panose 00000000000000000000}Helv;}{\f10\froman\fcharset0\fprq2{\*\panose 00000000000000000000}MS Serif;}
{\f11\fswiss\fcharset0\fprq2{\*\panose 00000000000000000000}MS Sans Serif;}{\f12\froman\fcharset0\fprq2{\*\panose 00000000000000000000}New York;}{\f13\fswiss\fcharset0\fprq2{\*\panose 00000000000000000000}System;}
{\f14\fnil\fcharset2\fprq2{\*\panose 05000000000000000000}Wingdings;}{\f15\fswiss\fcharset0\fprq2{\*\panose 020b0604030504040204}Tahoma;}{\f16\fnil\fcharset2\fprq2{\*\panose 00000000000000000000}Marlett;}
{\f17\froman\fcharset0\fprq2{\*\panose 02040602050305030304}Book Antiqua;}{\f18\fswiss\fcharset0\fprq2{\*\panose 020b0502020202020204}Century Gothic;}{\f19\fscript\fcharset0\fprq2{\*\panose 03010101010201010101}Monotype Corsiva;}
{\f20\froman\fcharset0\fprq2{\*\panose 02040604050505020304}Century Schoolbook;}{\f21\froman\fcharset2\fprq2{\*\panose 05050102010205020202}MT Extra;}{\f22\fdecor\fcharset0\fprq2{\*\panose 04020705040a02060702}Algerian;}
{\f23\fswiss\fcharset0\fprq2{\*\panose 020f0704030504030204}Arial Rounded MT Bold;}{\f24\fdecor\fcharset0\fprq2{\*\panose 04030b070d0b02020403}Braggadocio;}{\f25\fswiss\fcharset0\fprq2{\*\panose 020b0903060703020204}Britannic Bold;}
{\f26\fscript\fcharset0\fprq2{\*\panose 03060802040406070304}Brush Script MT;}{\f27\fdecor\fcharset0\fprq2{\*\panose 04020805060202030203}Colonna MT;}{\f28\fdecor\fcharset0\fprq2{\*\panose 04020505020e03040504}Desdemona;}
{\f29\froman\fcharset0\fprq2{\*\panose 0204060206030a020304}Footlight MT Light;}{\f30\fdecor\fcharset0\fprq2{\*\panose 040307050d0c02020703}Kino MT;}{\f31\froman\fcharset0\fprq2{\*\panose 020a0a07050505020404}Wide Latin;}
{\f32\fscript\fcharset0\fprq2{\*\panose 03020802060602070202}Matura MT Script Capitals;}{\f33\fdecor\fcharset0\fprq2{\*\panose 040506030a0602020202}Playbill;}{\f34\fscript\fcharset0\fprq2{\*\panose 03010500030000090005}Brush Script;}
{\f35\fswiss\fcharset0\fprq2{\*\panose 020b0502020104020203}Gill Sans;}{\f36\fmodern\fcharset0\fprq1{\*\panose 02000009000000000000}Letter Gothic;}{\f37\froman\fcharset0\fprq2{\*\panose 02020602050400010903}Perpetua;}
{\f38\fswiss\fcharset0\fprq2{\*\panose 020e0602050203020203}Lydian;}{\f39\fswiss\fcharset0\fprq2{\*\panose 020b0803020103020203}News Gothic;}{\f40\fswiss\fcharset0\fprq2{\*\panose 020b0606020003020203}News Gothic Condensed;}
{\f41\froman\fcharset0\fprq2{\*\panose 02040a02080005020203}Photina Casual Black;}{\f42\fswiss\fcharset0\fprq2{\*\panose 020b0506020202030204}Arial Narrow;}{\f43\froman\fcharset0\fprq2{\*\panose 02050604050505020204}Bookman Old Style;}
{\f44\fnil\fcharset2\fprq2{\*\panose 01010601010101010101}Monotype Sorts;}{\f45\fswiss\fcharset0\fprq2{\*\panose 020b0806030902050204}Impact;}{\f46\fswiss\fcharset0\fprq2{\*\panose 020b0a04020102020204}Arial Black;}
{\f47\froman\fcharset0\fprq2{\*\panose 02020404030301010803}Garamond;}{\f48\fswiss\fcharset0\fprq2{\*\panose 00000000000000000000}AvantGarde;}{\f49\froman\fcharset0\fprq2{\*\panose 00000000000000000000}Bookman;}
{\f50\fswiss\fcharset0\fprq2{\*\panose 00000000000000000000}Helvetica-Narrow;}{\f51\froman\fcharset0\fprq2{\*\panose 00000000000000000000}NewCenturySchlbk;}{\f52\froman\fcharset0\fprq2{\*\panose 00000000000000000000}Palatino;}
{\f53\froman\fcharset0\fprq2{\*\panose 00000000000000000000}ZapfChancery;}{\f54\fdecor\fcharset0\fprq2{\*\panose 00000000000000000000}ZapfDingbats;}{\f145\fswiss\fcharset238\fprq2 Tahoma CE;}{\f146\fswiss\fcharset204\fprq2 Tahoma Cyr;}
{\f148\fswiss\fcharset161\fprq2 Tahoma Greek;}{\f149\fswiss\fcharset162\fprq2 Tahoma Tur;}{\f150\fswiss\fcharset186\fprq2 Tahoma Baltic;}{\f307\fswiss\fcharset238\fprq2 Arial Narrow CE;}{\f308\fswiss\fcharset204\fprq2 Arial Narrow Cyr;}
{\f310\fswiss\fcharset161\fprq2 Arial Narrow Greek;}{\f311\fswiss\fcharset162\fprq2 Arial Narrow Tur;}{\f312\fswiss\fcharset186\fprq2 Arial Narrow Baltic;}{\f313\froman\fcharset238\fprq2 Bookman Old Style CE;}
{\f314\froman\fcharset204\fprq2 Bookman Old Style Cyr;}{\f316\froman\fcharset161\fprq2 Bookman Old Style Greek;}{\f317\froman\fcharset162\fprq2 Bookman Old Style Tur;}{\f318\froman\fcharset186\fprq2 Bookman Old Style Baltic;}
{\f325\fswiss\fcharset238\fprq2 Impact CE;}{\f326\fswiss\fcharset204\fprq2 Impact Cyr;}{\f328\fswiss\fcharset161\fprq2 Impact Greek;}{\f329\fswiss\fcharset162\fprq2 Impact Tur;}{\f330\fswiss\fcharset186\fprq2 Impact Baltic;}
{\f331\fswiss\fcharset238\fprq2 Arial Black CE;}{\f332\fswiss\fcharset204\fprq2 Arial Black Cyr;}{\f334\fswiss\fcharset161\fprq2 Arial Black Greek;}{\f335\fswiss\fcharset162\fprq2 Arial Black Tur;}{\f336\fswiss\fcharset186\fprq2 Arial Black Baltic;}
{\f337\froman\fcharset238\fprq2 Garamond CE;}{\f338\froman\fcharset204\fprq2 Garamond Cyr;}{\f340\froman\fcharset161\fprq2 Garamond Greek;}{\f341\froman\fcharset162\fprq2 Garamond Tur;}{\f342\froman\fcharset186\fprq2 Garamond Baltic;}}
{\colortbl;\red0\green0\blue0;\red0\green0\blue255;\red0\green255\blue255;\red0\green255\blue0;\red255\green0\blue255;\red255\green0\blue0;\red255\green255\blue0;\red255\green255\blue255;\red0\green0\blue128;\red0\green128\blue128;\red0\green128\blue0;
\red128\green0\blue128;\red128\green0\blue0;\red128\green128\blue0;\red128\green128\blue128;\red192\green192\blue192;}{\stylesheet{\qj\sb100\sa100\nowidctlpar\adjustright \fs22\lang2057 \snext0 Normal;}{
\s1\qc\sb100\sa100\keepn\nowidctlpar\outlinelevel0\adjustright \b\f1\lang2057 \sbasedon0 \snext0 heading 1;}{\s2\qj\sb240\sa60\keepn\nowidctlpar\adjustright \b\i\f1\lang2057 \sbasedon0 \snext0 heading 2;}{
\s3\qc\sb100\sa100\keepn\nowidctlpar\outlinelevel2\adjustright \f1\fs32\lang2057 \sbasedon0 \snext0 heading 3;}{\*\cs10 \additive Default Paragraph Font;}{\s15\qj\nowidctlpar\adjustright \fs22\lang2057 \sbasedon0 \snext16 Definition Term;}{
\s16\qj\li360\nowidctlpar\adjustright \fs22\lang2057 \sbasedon0 \snext15 Definition List;}{\*\cs17 \additive \i Definition;}{\s18\qj\sb100\sa100\keepn\nowidctlpar\outlinelevel1\adjustright \b\fs48\lang2057\kerning36 \sbasedon0 \snext0 H1;}{
\s19\qj\sb100\sa100\keepn\nowidctlpar\outlinelevel2\adjustright \b\fs36\lang2057 \sbasedon0 \snext0 H2;}{\s20\qj\sb100\sa100\keepn\nowidctlpar\outlinelevel3\adjustright \b\fs28\lang2057 \sbasedon0 \snext0 H3;}{
\s21\qj\sb100\sa100\keepn\nowidctlpar\outlinelevel4\adjustright \b\fs22\lang2057 \sbasedon0 \snext0 H4;}{\s22\qj\sb100\sa100\keepn\nowidctlpar\outlinelevel5\adjustright \b\fs20\lang2057 \sbasedon0 \snext0 H5;}{
\s23\qj\sb100\sa100\keepn\nowidctlpar\outlinelevel6\adjustright \b\fs16\lang2057 \sbasedon0 \snext0 H6;}{\s24\qj\nowidctlpar\adjustright \i\fs22\lang2057 \sbasedon0 \snext0 Address;}{\s25\qj\li360\ri360\sb100\sa100\nowidctlpar\adjustright \fs22\lang2057 
\sbasedon0 \snext25 Blockquote;}{\*\cs26 \additive \i CITE;}{\*\cs27 \additive \f2\fs20 CODE;}{\*\cs28 \additive \i \sbasedon10 Emphasis;}{\*\cs29 \additive \ul\cf2 \sbasedon10 Hyperlink;}{\*\cs30 \additive \ul\cf12 \sbasedon10 FollowedHyperlink;}{\*
\cs31 \additive \b\f2\fs20 Keyboard;}{\s32\qj\nowidctlpar\tx0\tx959\tx1918\tx2877\tx3836\tx4795\tx5754\tx6713\tx7672\tx8631\tx9590\adjustright \f2\fs20\lang2057 \sbasedon0 \snext32 Preformatted;}{\s33\qc\nowidctlpar\brdrt\brdrdb\brdrw5\brdrcf1 
\adjustright \v\f1\fs16\lang2057 \snext0 \shidden z-Bottom of Form;}{\s34\qc\nowidctlpar\brdrb\brdrdb\brdrw5\brdrcf1 \adjustright \v\f1\fs16\lang2057 \snext0 \shidden z-Top of Form;}{\*\cs35 \additive \f2 Sample;}{\*\cs36 \additive \b \sbasedon10 Strong;}
{\*\cs37 \additive \f2\fs20 Typewriter;}{\*\cs38 \additive \i Variable;}{\*\cs39 \additive \v\cf6 HTML Markup;}{\*\cs40 \additive \v Comment;}{\s41\qj\li567\ri567\sb100\sa100\nowidctlpar\brdrt\brdrs\brdrw10\brsp20 \brdrl\brdrs\brdrw10\brsp80 \brdrb
\brdrs\brdrw10\brsp20 \brdrr\brdrs\brdrw10\brsp80 \adjustright \fs22\lang2057 \sbasedon0 \snext41 Block Text;}{\s42\sb120\sa120\nowidctlpar\adjustright \b\caps\fs20\lang2057 \sbasedon0 \snext0 \sautoupd toc 1;}{\s43\li220\nowidctlpar\adjustright 
\scaps\fs20\lang2057 \sbasedon0 \snext0 \sautoupd toc 2;}{\s44\li440\nowidctlpar\adjustright \i\fs20\lang2057 \sbasedon0 \snext0 \sautoupd toc 3;}{\s45\li660\nowidctlpar\adjustright \fs18\lang2057 \sbasedon0 \snext0 \sautoupd toc 4;}{
\s46\li880\nowidctlpar\adjustright \fs18\lang2057 \sbasedon0 \snext0 \sautoupd toc 5;}{\s47\li1100\nowidctlpar\adjustright \fs18\lang2057 \sbasedon0 \snext0 \sautoupd toc 6;}{\s48\li1320\nowidctlpar\adjustright \fs18\lang2057 \sbasedon0 \snext0 \sautoupd 
toc 7;}{\s49\li1540\nowidctlpar\adjustright \fs18\lang2057 \sbasedon0 \snext0 \sautoupd toc 8;}{\s50\li1760\nowidctlpar\adjustright \fs18\lang2057 \sbasedon0 \snext0 \sautoupd toc 9;}{\s51\qc\sb100\sa100\nowidctlpar\adjustright \f1\fs48\lang2057 
\sbasedon0 \snext51 Title;}{\s52\qc\sb100\sa100\keepn\nowidctlpar\outlinelevel2\adjustright \f1\fs32\lang2057 \sbasedon3 \snext52 Company name;}{\s53\qj\sb100\sa100\nowidctlpar\tqc\tx4153\tqr\tx8306\adjustright \fs22\lang2057 \sbasedon0 \snext53 header;}{
\s54\qj\sb100\sa100\nowidctlpar\tqc\tx4153\tqr\tx8306\adjustright \fs22\lang2057 \sbasedon0 \snext54 footer;}{\*\cs55 \additive \sbasedon10 page number;}}{\*\listtable{\list\listtemplateid-1\listsimple{\listlevel\levelnfc0\leveljc0\levelfollow0
\levelstartat0\levelspace0\levelindent0{\leveltext\'01*;}{\levelnumbers;}}{\listname ;}\listid-2}{\list\listtemplateid134807567\listsimple{\listlevel\levelnfc0\leveljc0\levelfollow0\levelstartat1\levelspace0\levelindent0{\leveltext
\'02\'00.;}{\levelnumbers\'01;}\fbias0 \fi-360\li360\jclisttab\tx360 }{\listname ;}\listid1104880785}}{\*\listoverridetable{\listoverride\listid-2\listoverridecount1{\lfolevel\listoverrideformat{\listlevel\levelnfc23\leveljc0\levelfollow0\levelstartat0
\levelold\levelspace0\levelindent360{\leveltext\'01\u-3913 ?;}{\levelnumbers;}\f3\fbias0 \fi-360\li720 }}\ls1}{\listoverride\listid-2\listoverridecount1{\lfolevel\listoverrideformat{\listlevel\levelnfc23\leveljc0\levelfollow0\levelstartat0\levelold
\levelspace0\levelindent360{\leveltext\'01\u-3913 ?;}{\levelnumbers;}\f3\fbias0 \fi-360\li720 }}\ls2}{\listoverride\listid-2\listoverridecount1{\lfolevel\listoverrideformat{\listlevel\levelnfc23\leveljc0\levelfollow0\levelstartat0\levelold\levelspace0
\levelindent360{\leveltext\'01\u-3913 ?;}{\levelnumbers;}\f3\fbias0 \fi-360\li720 }}\ls3}{\listoverride\listid-2\listoverridecount1{\lfolevel\listoverrideformat{\listlevel\levelnfc23\leveljc0\levelfollow0\levelstartat0\levelold\levelspace0\levelindent360
{\leveltext\'01\u-3913 ?;}{\levelnumbers;}\f3\fbias0 \fi-360\li720 }}\ls4}{\listoverride\listid1104880785\listoverridecount0\ls5}}{\*\revtbl {Unknown;}}{\info{\title YAZ User's Guide and Reference: Introduction}{\author Sebastian Hammer}{\operator Sebastian Hammer}
{\creatim\yr1997\mo9\dy17\hr11\min49}{\revtim\yr1997\mo9\dy17\hr14\min14}{\version5}{\edmins26}{\nofpages49}{\nofwords16640}{\nofchars94849}{\*\company Index Data}{\nofcharsws116481}{\vern71}}
\paperw11906\paperh16838\margl1273\margr1273\margt1417\margb1134 \widowctrl\ftnbj\aenddoc\hyphcaps0\viewkind1\viewscale100 \fet0\sectd \linex0\headery1440\footery1440\colsx709\titlepg\sectdefaultcl {\footer \pard\plain 
\s54\qc\ri360\sb100\sa100\nowidctlpar\tqc\tx4153\tqr\tx8306\adjustright \fs22\lang2057 {\cs55 - }{\field{\*\fldinst {\cs55 PAGE  }}{\fldrslt {\cs55\lang1024 34}}}{\cs55  -}{\cs55\v \'00}{
\par }}{\*\pnseclvl1\pnucrm\pnstart1\pnindent720\pnhang{\pntxta .}}{\*\pnseclvl2\pnucltr\pnstart1\pnindent720\pnhang{\pntxta .}}{\*\pnseclvl3\pndec\pnstart1\pnindent720\pnhang{\pntxta .}}{\*\pnseclvl4\pnlcltr\pnstart1\pnindent720\pnhang{\pntxta )}}
{\*\pnseclvl5\pndec\pnstart1\pnindent720\pnhang{\pntxtb (}{\pntxta )}}{\*\pnseclvl6\pnlcltr\pnstart1\pnindent720\pnhang{\pntxtb (}{\pntxta )}}{\*\pnseclvl7\pnlcrm\pnstart1\pnindent720\pnhang{\pntxtb (}{\pntxta )}}{\*\pnseclvl8
\pnlcltr\pnstart1\pnindent720\pnhang{\pntxtb (}{\pntxta )}}{\*\pnseclvl9\pnlcrm\pnstart1\pnindent720\pnhang{\pntxtb (}{\pntxta )}}\pard\plain \s51\qc\sb100\sa100\nowidctlpar\adjustright \f1\fs48\lang2057 {{\*\bkmkstart s1}YAZ User's Guide and Reference

\par }\pard\plain \qc\sb100\sa100\nowidctlpar\adjustright \fs22\lang2057 {YAZ version 1.4
\par }\pard\plain \s51\qc\sb100\sa100\nowidctlpar\adjustright \f1\fs48\lang2057 {\fs40 Index Data
\par }\pard\plain \qc\sb100\sa100\nowidctlpar\adjustright \fs22\lang2057 {
\par }\pard\plain \s41\qj\li567\ri567\sb100\sa100\nowidctlpar\brdrt\brdrs\brdrw10\brsp20 \brdrl\brdrs\brdrw10\brsp80 \brdrb\brdrs\brdrw10\brsp20 \brdrr\brdrs\brdrw10\brsp80 \adjustright \fs22\lang2057 {\cs28\i This document is the programmer's guide and re
ference to the YAZ package. YAZ is a compact toolkit that provides access to the Z39.50/SR protocol, as well as a set of higher-level tools for implementing the server and client roles, respectively. The documentation can be used on its own, or as a refer
ence when looking at the example applications provided with the package.}{
\par }\pard\plain \qj\sb100\sa100\nowidctlpar\adjustright \fs22\lang2057 {
\par }\pard\plain \s44\li440\nowidctlpar\tqr\tldot\tx9350\adjustright \i\fs20\lang2057 {\field\fldedit{\*\fldinst { TOC \\o "1-3" }}{\fldrslt {\lang1024 1. Introduction\tab }{\field{\*\fldinst {\lang1024  PAGEREF _Toc399132415 \\h }{\lang1024 {\*\datafield 
08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003300390039003100330032003400310035000000}}}{\fldrslt {\lang1024 2}}}{\lang1024 
\par 2. Compilation and Installation\tab }{\field{\*\fldinst {\lang1024  PAGEREF _Toc399132416 \\h }{\lang1024 {\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003300390039003100330032003400310036000000}}}{\fldrslt {
\lang1024 3}}}{\lang1024 
\par 3. The ASN Module\tab }{\field{\*\fldinst {\lang1024  PAGEREF _Toc399132417 \\h }{\lang1024 {\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003300390039003100330032003400310037000000}}}{\fldrslt {\lang1024 4}}}{
\lang1024 
\par 3.1 Introduction\tab }{\field{\*\fldinst {\lang1024  PAGEREF _Toc399132418 \\h }{\lang1024 {\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003300390039003100330032003400310038000000}}}{\fldrslt {\lang1024 4}}}{
\lang1024 
\par 3.2 Preparing PDUs\tab }{\field{\*\fldinst {\lang1024  PAGEREF _Toc399132419 \\h }{\lang1024 {\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003300390039003100330032003400310039000000}}}{\fldrslt {\lang1024 4}}}{
\lang1024 
\par 3.3 Object Identifiers\tab }{\field{\*\fldinst {\lang1024  PAGEREF _Toc399132420 \\h }{\lang1024 {\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003300390039003100330032003400320030000000}}}{\fldrslt {\lang1024 5}}}{
\lang1024 
\par 3.4 EXTERNAL Data\tab }{\field{\*\fldinst {\lang1024  PAGEREF _Toc399132421 \\h }{\lang1024 {\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003300390039003100330032003400320031000000}}}{\fldrslt {\lang1024 6}}}{
\lang1024 
\par 3.5 PDU Contents Table\tab }{\field{\*\fldinst {\lang1024  PAGEREF _Toc399132422 \\h }{\lang1024 {\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003300390039003100330032003400320032000000}}}{\fldrslt {\lang1024 7}}}{
\lang1024 
\par 4. Supporting Tools\tab }{\field{\*\fldinst {\lang1024  PAGEREF _Toc399132423 \\h }{\lang1024 {\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003300390039003100330032003400320033000000}}}{\fldrslt {\lang1024 11}}}{
\lang1024 
\par 4.1 Query Syntax Parsers\tab }{\field{\*\fldinst {\lang1024  PAGEREF _Toc399132424 \\h }{\lang1024 {\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003300390039003100330032003400320034000000}}}{\fldrslt {\lang1024 11}
}}{\lang1024 
\par 4.2 Object Identifiers\tab }{\field{\*\fldinst {\lang1024  PAGEREF _Toc399132425 \\h }{\lang1024 {\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003300390039003100330032003400320035000000}}}{\fldrslt {\lang1024 16}}}{
\lang1024 
\par 4.3 Nibble Memory\tab }{\field{\*\fldinst {\lang1024  PAGEREF _Toc399132426 \\h }{\lang1024 {\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003300390039003100330032003400320036000000}}}{\fldrslt {\lang1024 18}}}{
\lang1024 
\par 5. The ODR Module\tab }{\field{\*\fldinst {\lang1024  PAGEREF _Toc399132427 \\h }{\lang1024 {\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003300390039003100330032003400320037000000}}}{\fldrslt {\lang1024 19}}}{
\lang1024 
\par 5.1 Introduction\tab }{\field{\*\fldinst {\lang1024  PAGEREF _Toc399132428 \\h }{\lang1024 {\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003300390039003100330032003400320038000000}}}{\fldrslt {\lang1024 19}}}{
\lang1024 
\par 5.2 Using ODR\tab }{\field{\*\fldinst {\lang1024  PAGEREF _Toc399132429 \\h }{\lang1024 {\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003300390039003100330032003400320039000000}}}{\fldrslt {\lang1024 19}}}{
\lang1024 
\par 5.3 Programming with ODR\tab }{\field{\*\fldinst {\lang1024  PAGEREF _Toc399132430 \\h }{\lang1024 {\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003300390039003100330032003400330030000000}}}{\fldrslt {\lang1024 24}
}}{\lang1024 
\par 5.4 Debugging\tab }{\field{\*\fldinst {\lang1024  PAGEREF _Toc399132431 \\h }{\lang1024 {\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003300390039003100330032003400330031000000}}}{\fldrslt {\lang1024 32}}}{
\lang1024 
\par 6. The COMSTACK Module\tab }{\field{\*\fldinst {\lang1024  PAGEREF _Toc399132432 \\h }{\lang1024 {\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003300390039003100330032003400330032000000}}}{\fldrslt {\lang1024 32}}}{
\lang1024 
\par 6.1 Introduction\tab }{\field{\*\fldinst {\lang1024  PAGEREF _Toc399132433 \\h }{\lang1024 {\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003300390039003100330032003400330033000000}}}{\fldrslt {\lang1024 32}}}{
\lang1024 
\par 6.2 Common Functions\tab }{\field{\*\fldinst {\lang1024  PAGEREF _Toc399132434 \\h }{\lang1024 {\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003300390039003100330032003400330034000000}}}{\fldrslt {\lang1024 32}}}{
\lang1024 
\par 6.3 Client Side\tab }{\field{\*\fldinst {\lang1024  PAGEREF _Toc399132435 \\h }{\lang1024 {\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003300390039003100330032003400330035000000}}}{\fldrslt {\lang1024 34}}}{
\lang1024 
\par 6.4 Server Side\tab }{\field{\*\fldinst {\lang1024  PAGEREF _Toc399132436 \\h }{\lang1024 {\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003300390039003100330032003400330036000000}}}{\fldrslt {\lang1024 34}}}{
\lang1024 
\par 6.5 Addresses\tab }{\field{\*\fldinst {\lang1024  PAGEREF _Toc399132437 \\h }{\lang1024 {\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003300390039003100330032003400330037000000}}}{\fldrslt {\lang1024 35}}}{
\lang1024 
\par 6.6 Diagnostics\tab }{\field{\*\fldinst {\lang1024  PAGEREF _Toc399132438 \\h }{\lang1024 {\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003300390039003100330032003400330038000000}}}{\fldrslt {\lang1024 36}}}{
\lang1024 
\par 6.7 Enabling OSI Communication\tab }{\field{\*\fldinst {\lang1024  PAGEREF _Toc399132439 \\h }{\lang1024 {\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003300390039003100330032003400330039000000}}}{\fldrslt {
\lang1024 36}}}{\lang1024 
\par 6.8 Summary and Synopsis\tab }{\field{\*\fldinst {\lang1024  PAGEREF _Toc399132440 \\h }{\lang1024 {\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003300390039003100330032003400340030000000}}}{\fldrslt {\lang1024 38}
}}{\lang1024 
\par 7. Making an IR Interface for Your Database with YAZ\tab }{\field{\*\fldinst {\lang1024  PAGEREF _Toc399132441 \\h }{\lang1024 {\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003300390039003100330032003400340031000000
}}}{\fldrslt {\lang1024 38}}}{\lang1024 
\par 7.1 Introduction\tab }{\field{\*\fldinst {\lang1024  PAGEREF _Toc399132442 \\h }{\lang1024 {\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003300390039003100330032003400340032000000}}}{\fldrslt {\lang1024 38}}}{
\lang1024 
\par 7.2 The Database Frontend\tab }{\field{\*\fldinst {\lang1024  PAGEREF _Toc399132443 \\h }{\lang1024 {\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003300390039003100330032003400340033000000}}}{\fldrslt {\lang1024 39}
}}{\lang1024 
\par 7.3 The Backend API\tab }{\field{\*\fldinst {\lang1024  PAGEREF _Toc399132444 \\h }{\lang1024 {\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003300390039003100330032003400340034000000}}}{\fldrslt {\lang1024 39}}}{
\lang1024 
\par 7.4 Your main() Routine\tab }{\field{\*\fldinst {\lang1024  PAGEREF _Toc399132445 \\h }{\lang1024 {\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003300390039003100330032003400340035000000}}}{\fldrslt {\lang1024 40}}}
{\lang1024 
\par 7.5 The Backend Functions\tab }{\field{\*\fldinst {\lang1024  PAGEREF _Toc399132446 \\h }{\lang1024 {\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003300390039003100330032003400340036000000}}}{\fldrslt {\lang1024 41}
}}{\lang1024 
\par 7.6 Application Invocation\tab }{\field{\*\fldinst {\lang1024  PAGEREF _Toc399132447 \\h }{\lang1024 {\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003300390039003100330032003400340037000000}}}{\fldrslt {\lang1024 44
}}}{\lang1024 
\par 7.7 Summary and Synopsis\tab }{\field{\*\fldinst {\lang1024  PAGEREF _Toc399132448 \\h }{\lang1024 {\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003300390039003100330032003400340038000000}}}{\fldrslt {\lang1024 46}
}}{\lang1024 
\par 8. Future Directions\tab }{\field{\*\fldinst {\lang1024  PAGEREF _Toc399132449 \\h }{\lang1024 {\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003300390039003100330032003400340039000000}}}{\fldrslt {\lang1024 46}}}{
\lang1024 
\par 9. License\tab }{\field{\*\fldinst {\lang1024  PAGEREF _Toc399132450 \\h }{\lang1024 {\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003300390039003100330032003400350030000000}}}{\fldrslt {\lang1024 47}}}{\lang1024 

\par 9.1 Index Data Copyright\tab }{\field{\*\fldinst {\lang1024  PAGEREF _Toc399132451 \\h }{\lang1024 {\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003300390039003100330032003400350031000000}}}{\fldrslt {\lang1024 47}
}}{\lang1024 
\par 9.2 Additional Copyright Statements\tab }{\field{\*\fldinst {\lang1024  PAGEREF _Toc399132452 \\h }{\lang1024 {\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003300390039003100330032003400350032000000}}}{\fldrslt {
\lang1024 47}}}{\lang1024 
\par 10. About Index Data\tab }{\field{\*\fldinst {\lang1024  PAGEREF _Toc399132453 \\h }{\lang1024 {\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003300390039003100330032003400350033000000}}}{\fldrslt {\lang1024 48}}}{
\lang1024 
\par }\pard\plain \qj\sb100\sa100\nowidctlpar\adjustright \fs22\lang2057 }}\pard\plain \qj\sb100\sa100\nowidctlpar\adjustright \fs22\lang2057 {
\par 
\par {\*\bkmkstart _Toc399132415}{\pntext\pard\plain\s19 \b\fs36 \hich\af0\dbch\af0\loch\f0 1.\tab}}\pard\plain \s19\qj\fi-360\li360\sb100\sa100\keepn\nowidctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls5\pnrnot0\pndec\pnstart1\pnindent360\pnhang{\pntxta .}}
\ls5\outlinelevel2\adjustright \b\fs36\lang2057 {Introduction{\*\bkmkend s1}{\*\bkmkend _Toc399132415}
\par }\pard\plain \qj\sb100\sa100\nowidctlpar\adjustright \fs22\lang2057 {The }{\i Hacker's Jargon File}{ has the following to say about the use of the prefix "YA" in the name of a software product.
\par }{\i Yet Another. adj. 1. Of your own work: A humorous allusion often used in titles to acknowledge that the topic is not original, though the content is. As in "Yet A
nother AI Group" or "Yet Another Simulated Annealing Algorithm". 2. Of others' work: Describes something of which there are already far too many. }{
\par The }{\b YAZ}{ toolkit offers several different levels of access to the Z39.50 and SR protocols. The level that you need to use depends on your requirements, and the role (server or client) that you want to implement.
\par The basic level, which is independent of the role, consists of three primary interfaces:
\par {\pntext\pard\plain\f3\fs22 \loch\af3\dbch\af0\hich\f3 \'b7\tab}}\pard \qj\fi-360\li720\sb100\sa100\nowidctlpar{\*\pn \pnlvlblt\ilvl0\ls1\pnrnot0\pnf3\pnindent360\pnhang{\pntxtb \'b7}}\ls1\adjustright {\b ASN}{
, which provides a C representation of the Z39.50/SR protocol packages (PDUs). 
\par {\pntext\pard\plain\f3\fs22 \loch\af3\dbch\af0\hich\f3 \'b7\tab}}\pard \qj\fi-360\li720\sb100\sa100\nowidctlpar{\*\pn \pnlvlblt\ilvl0\ls1\pnrnot0\pnf3\pnindent360\pnhang{\pntxtb \'b7}}\ls1\adjustright {\b ODR}{
, which encodes and decodes the packages according to the BER specification. 
\par {\pntext\pard\plain\f3\fs22 \loch\af3\dbch\af0\hich\f3 \'b7\tab}}\pard \qj\fi-360\li720\sb100\sa100\nowidctlpar{\*\pn \pnlvlblt\ilvl0\ls1\pnrnot0\pnf3\pnindent360\pnhang{\pntxtb \'b7}}\ls1\adjustright {\b COMSTACK}{
, which exchanges the encoded packages with a peer process over a network. 
\par }\pard \qj\sb100\sa100\nowidctlpar{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright {The ASN module represents the ASN.1 definition of the SR/Z39.50 
protocol. It establishes a set of type and structure definitions, with one structure for each of the top-level PDUs, and one structure or type for each of the contained ASN.1 types. For primitive types, or other types that are defined by the ASN.1 standar
d itself (such as the EXTERNAL type), the C representation is provided by the }{\b ODR}{ (Open Data Representation) subsystem.
\par }{\b ODR}{ is a basic mechanism for representing an ASN.1 type in the C programming language, and for implementing BER encoders and decoders for values of that type. The types defined in the }{\b ASN}{ module generally have the prefix }{\cs27\f2\fs20 Z_}{
, and a suffix corresponding to the name of the type in the ASN.1 specification of the protocol (generally Z39.50-1995). In the case of base types (those originating in the ASN.1 standard itself), the prefix }{\cs27\f2\fs20 Odr_}{
 is sometimes seen. Either way, look for the actual definition in either }{\cs27\f2\fs20 proto.h}{ (for the types from the protocol), }{\cs27\f2\fs20 odr.h}{ (for the primitive ASN.1 types, or }{\cs27\f2\fs20 odr_use.h}{ (for the ASN.1 }{\i useful}{
 types). The }{\b ASN}{ library also provides functions (which are, in turn, defined using }{\b ODR}{ primitives) for encoding and decoding data values. Their general form is
\par }\pard\plain \s32\qj\li360\ri360\nowidctlpar\tx0\tx959\tx1918\tx2877\tx3836\tx4795\tx5754\tx6713\tx7672\tx8631{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright \f2\fs20\lang2057 {\cs27 
\par int z_xxx(ODR o, Z_xxx **p, int optional);
\par }\pard\plain \qj\sb100\sa100\nowidctlpar{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright \fs22\lang2057 {(note the lower-case "z" in the function name)
\par }{\i NOTE: If you are using the premade definitions of the }{\b\i ASN}{\i  module, and you are not adding new protocol of your own, the only parts of ODR that you need to worry about are documented in section }{\field{\*\fldinst {\i 
HYPERLINK "yaz-5.html" \\l "odr-use"}{\i\fs20 {\*\datafield 
08d0c9ea79f9bace118c8200aa004ba90b02000000090000000303000000000000c00000000000004600000b00000059415a2d352e48544d4c00ffffadde00000000000000000000000000000000000000001a000000140000000300790061007a002d0035002e00680074006d006c00080000006f00640072002d00750073
00650000000000000000000000}}}{\fldrslt {\cs29\i\ul\cf2 Using ODR}}}{\i .}{
\par When you have created a BER-encoded buffer, you can use the }{\b COMSTACK}{ subsystem to transmit (or receive) data over the network. The }{\b COMSTACK}{ module provides simple func
tions for establishing a connection (passively or actively, depending on the role of your application), and for exchanging BER-encoded PDUs over that connection. When you create a connection endpoint, you need to specify what transport to use (OSI or TCP/
IP), and which protocol you want to use (SR or Z39.50). For the remainer of the connection's lifetime, you don't have to worry about the underlying transport protocol at all - the }{\b COMSTACK}{ will ensure that the correct mechanism is used.
\par We call the combined interfaces to }{\b ODR}{, }{\b ASN}{, and }{\b COMSTACK}{
 the service level API. It's the API that most closely models the Z39.50/SR service/protocol definition, and it provides unlimited access to all fields and facilities of the protocol definitions.
\par The reason that the }{\b YAZ}{
 service-level API is a conglomerate of the APIs from three different submodules is twofold. First, we wanted to allow the user a choice of different options for each major task. For instance, if you don't like the protocol API provided by }{\b ODR}{/}{
\b ASN}{, you can use SNACC or BERUtils instead, and still have the benefits of the transparent transport approach of the }{\b COMSTACK}{
 module. Secondly, we realise that you may have to fit the toolkit into an existing event-processing structure, in a way that is incompatible with the }{\b COMSTACK}{ interface or some other part of }{\b YAZ}{.
\par }\pard\plain \s19\qj\sb100\sa100\keepn\nowidctlpar{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\outlinelevel2\adjustright \b\fs36\lang2057 {{\*\bkmkstart s2}{\*\bkmkstart _Toc399132416}2. Compilation and Installation{\*\bkmkend s2}{\*\bkmkend _Toc399132416}

\par }\pard\plain \qj\sb100\sa100\nowidctlpar{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright \fs22\lang2057 {The latest version of the software will generally be found at
\par }\pard\plain \s32\qj\li360\ri360\nowidctlpar\tx0\tx959\tx1918\tx2877\tx3836\tx4795\tx5754\tx6713\tx7672\tx8631{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright \f2\fs20\lang2057 {\cs27 
\par ftp://ftp.indexdata.dk/index/yaz/
\par }\pard\plain \qj\sb100\sa100\nowidctlpar{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright \fs22\lang2057 {If you can't get through to this server, try the mirror site at
\par }\pard\plain \s32\qj\li360\ri360\nowidctlpar\tx0\tx959\tx1918\tx2877\tx3836\tx4795\tx5754\tx6713\tx7672\tx8631{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright \f2\fs20\lang2057 {\cs27 
\par ftp://ftp.funet.fi/pub/doc/library/z3950/yaz/
\par }\pard\plain \qj\sb100\sa100\nowidctlpar{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright \fs22\lang2057 {
When you unpack the distribution archive, it will create a directory which contains the top-level makefile as well as subdirectories for each of the modules.
\par Generally, it should be sufficient to run }{\cs27\f2\fs20 make}{
 in this directory. We have tried our best to keep the software portable, and on many platforms, you should be able to compile everything with little or no changes. You may need to update the main makefile to tell the demo applications wher
e to find the socket library, etc., and in some cases you'll need to jiggle the include files a bit. So far, the software has been ported to the following platforms with little or no difficulties.
\par {\pntext\pard\plain\f3\fs22 \loch\af3\dbch\af0\hich\f3 \'b7\tab}}\pard \qj\fi-360\li720\sb100\sa100\nowidctlpar{\*\pn \pnlvlblt\ilvl0\ls1\pnrnot0\pnf3\pnindent360\pnhang{\pntxtb \'b7}}\ls1\adjustright {Unix systems 
\par {\pntext\pard\plain\f3\fs22 \loch\af3\dbch\af0\hich\f3 \'b7\tab}}\pard \qj\fi-360\li1440\sb100\sa100\nowidctlpar{\*\pn \pnlvlblt\ilvl0\ls1\pnrnot0\pnf3\pnindent360\pnhang{\pntxtb \'b7}}\ls1\adjustright {HP/UX 
\par {\pntext\pard\plain\f3\fs22 \loch\af3\dbch\af0\hich\f3 \'b7\tab}}\pard \qj\fi-360\li1440\sb100\sa100\nowidctlpar{\*\pn \pnlvlblt\ilvl0\ls1\pnrnot0\pnf3\pnindent360\pnhang{\pntxtb \'b7}}\ls1\adjustright {SunOS/Solaris 
\par {\pntext\pard\plain\f3\fs22 \loch\af3\dbch\af0\hich\f3 \'b7\tab}}\pard \qj\fi-360\li1440\sb100\sa100\nowidctlpar{\*\pn \pnlvlblt\ilvl0\ls1\pnrnot0\pnf3\pnindent360\pnhang{\pntxtb \'b7}}\ls1\adjustright {DEC Unix 
\par {\pntext\pard\plain\f3\fs22 \loch\af3\dbch\af0\hich\f3 \'b7\tab}}\pard \qj\fi-360\li1440\sb100\sa100\nowidctlpar{\*\pn \pnlvlblt\ilvl0\ls1\pnrnot0\pnf3\pnindent360\pnhang{\pntxtb \'b7}}\ls1\adjustright {Linux 
\par {\pntext\pard\plain\f3\fs22 \loch\af3\dbch\af0\hich\f3 \'b7\tab}}\pard \qj\fi-360\li1440\sb100\sa100\nowidctlpar{\*\pn \pnlvlblt\ilvl0\ls1\pnrnot0\pnf3\pnindent360\pnhang{\pntxtb \'b7}}\ls1\adjustright {IBM AIX 
\par {\pntext\pard\plain\f3\fs22 \loch\af3\dbch\af0\hich\f3 \'b7\tab}}\pard \qj\fi-360\li1440\sb100\sa100\nowidctlpar{\*\pn \pnlvlblt\ilvl0\ls1\pnrnot0\pnf3\pnindent360\pnhang{\pntxtb \'b7}}\ls1\adjustright {Data General DG/UX (with some CFLAGS tinkering) 

\par {\pntext\pard\plain\f3\fs22 \loch\af3\dbch\af0\hich\f3 \'b7\tab}}\pard \qj\fi-360\li1440\sb100\sa100\nowidctlpar{\*\pn \pnlvlblt\ilvl0\ls1\pnrnot0\pnf3\pnindent360\pnhang{\pntxtb \'b7}}\ls1\adjustright {SGI/IRIX 
\par {\pntext\pard\plain\f3\fs22 \loch\af3\dbch\af0\hich\f3 \'b7\tab}}\pard \qj\fi-360\li1440\sb100\sa100\nowidctlpar{\*\pn \pnlvlblt\ilvl0\ls1\pnrnot0\pnf3\pnindent360\pnhang{\pntxtb \'b7}}\ls1\adjustright {DDE Supermax 
\par {\pntext\pard\plain\f3\fs22 \loch\af3\dbch\af0\hich\f3 \'b7\tab}}\pard \qj\fi-360\li720\sb100\sa100\nowidctlpar{\*\pn \pnlvlblt\ilvl0\ls1\pnrnot0\pnf3\pnindent360\pnhang{\pntxtb \'b7}}\ls1\adjustright {Non-unix systems 
\par {\pntext\pard\plain\f3\fs22 \loch\af3\dbch\af0\hich\f3 \'b7\tab}}\pard \qj\fi-360\li1440\sb100\sa100\nowidctlpar{\*\pn \pnlvlblt\ilvl0\ls1\pnrnot0\pnf3\pnindent360\pnhang{\pntxtb \'b7}}\ls1\adjustright {
Apple Macintosh (using the Codewarrior programming environment and the GUSI socket libraries) 
\par {\pntext\pard\plain\f3\fs22 \loch\af3\dbch\af0\hich\f3 \'b7\tab}}\pard \qj\fi-360\li1440\sb100\sa100\nowidctlpar{\*\pn \pnlvlblt\ilvl0\ls1\pnrnot0\pnf3\pnindent360\pnhang{\pntxtb \'b7}}\ls1\adjustright {MS Windows 95/NT (Win32) 
\par {\pntext\pard\plain\f3\fs22 \loch\af3\dbch\af0\hich\f3 \'b7\tab}}\pard \qj\fi-360\li1440\sb100\sa100\nowidctlpar{\*\pn \pnlvlblt\ilvl0\ls1\pnrnot0\pnf3\pnindent360\pnhang{\pntxtb \'b7}}\ls1\adjustright {IBM AS/400 
\par {\pntext\pard\plain\f3\fs22 \loch\af3\dbch\af0\hich\f3 \'b7\tab}}\pard \qj\fi-360\li1440\sb100\sa100\nowidctlpar{\*\pn \pnlvlblt\ilvl0\ls1\pnrnot0\pnf3\pnindent360\pnhang{\pntxtb \'b7}}\ls1\adjustright {Digital VAX/VMS and AXP/OpenVMS
\par }\pard \qj\sb100\sa100\nowidctlpar{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright {Note that if your system doesn't have a native ANSI C compiler, you may have to acquire one separately. We recommend gcc.
\par If you move the software to other platforms, we'd be grateful if you'd let us know abou
t it. If you run into difficulties, we will try to help if we can, and if you solve the problems, we would be happy to include your fixes in the next release. So far, we have mostly avoided #ifdefs for individual platforms, and we'd like to keep it that w
ay as far as it makes sense.
\par We maintain a mailing-list for the purpose of announcing new releases and bug-fixes, as well as general discussion. Subscribe by sending mail to }{\cs27\f2\fs20 yaz-request@index.ping.dk}{. General questions and problems can be directed at }{
\cs27\f2\fs20 yaz-help@index.ping.dk}{, or the address given at the top of this document.
\par }\pard\plain \s19\qj\sb100\sa100\keepn\nowidctlpar{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\outlinelevel2\adjustright \b\fs36\lang2057 {\b0\fs24 {\*\bkmkstart s3}
\par }{{\*\bkmkstart _Toc399132417}3. The ASN Module{\*\bkmkend s3}{\*\bkmkend _Toc399132417}
\par {\*\bkmkstart ss3_1}{\*\bkmkstart _Toc399132418}3.1 Introduction{\*\bkmkend ss3_1}{\*\bkmkend _Toc399132418}
\par }\pard\plain \qj\sb100\sa100\nowidctlpar{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright \fs22\lang2057 {The }{\b ASN}{ module provides you with a set of C struct definitions for the various PDUs of
 the protocol, as well as for the complex types appearing within the PDUs. For the primitive data types, the C representation often takes the form of an ordinary C language type, such as }{\cs27\f2\fs20 int}{
. For ASN.1 constructs that have no direct representation in C, such as general octet strings and bit strings, the }{\b ODR}{ module (see section }{\field{\*\fldinst {HYPERLINK "yaz-5.html" \\l "odr"}{\fs20 {\*\datafield 
08d0c9ea79f9bace118c8200aa004ba90b02000000090000000303000000000000c00000000000004600000b00000079617a2d352e68746d6c00ffffadde000000000000000000000000000000000000000000000000040000006f006400720000000000}}}{\fldrslt {\cs29\ul\cf2 ODR}}}{
) provides auxiliary definitions.
\par }\pard\plain \s19\qj\sb100\sa100\keepn\nowidctlpar{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\outlinelevel2\adjustright \b\fs36\lang2057 {{\*\bkmkstart ss3_2}{\*\bkmkstart _Toc399132419}3.2 Preparing PDUs{\*\bkmkend ss3_2}{\*\bkmkend _Toc399132419}
\par }\pard\plain \qj\sb100\sa100\nowidctlpar{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright \fs22\lang2057 {A structure representing a complex ASN.1 type doesn't in itself contain the members of that type. Instead, the structure contains }{\i pointers
}{ to the members of the type. This is necessary, in part, to allow a mechanism for specifying which of the optional structure (SEQUENCE) members are present, and which are not.
 It follows that you will need to somehow provide space for the individual members of the structure, and set the pointers to refer to the members.
\par The conversion routines don't care how you allocate and maintain your C structures - they just follow the poi
nters that you provide. Depending on the complexity of your application, and your personal taste, there are at least three different approaches that you may take when you allocate the structures.
\par {\pntext\pard\plain\f3\fs22 \loch\af3\dbch\af0\hich\f3 \'b7\tab}}\pard \qj\fi-360\li720\sb100\sa100\nowidctlpar{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnindent360\pnhang{\pntxtb \'b7}}\ls2\adjustright {
You can use static or automatic local variables in the fu
nction that prepares the PDU. This is a simple approach, and it provides the most efficient form of memory management. While it works well for flat PDUs like the InitReqest, it will generally not be sufficient for say, the generation of an arbitrarily com
plex RPN query structure. 
\par {\pntext\pard\plain\f3\fs22 \loch\af3\dbch\af0\hich\f3 \'b7\tab}}\pard \qj\fi-360\li720\sb100\sa100\nowidctlpar{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnindent360\pnhang{\pntxtb \'b7}}\ls2\adjustright {
You can individually create the structure and its members using the }{\cs27\f2\fs20 malloc}{(2) function. If you want to ensure that the data is freed when it is no longer needed, you will have to define a function that individually releases eac
h member of a structure before freeing the structure itself. 
\par {\pntext\pard\plain\f3\fs22 \loch\af3\dbch\af0\hich\f3 \'b7\tab}}\pard \qj\fi-360\li720\sb100\sa100\nowidctlpar{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnindent360\pnhang{\pntxtb \'b7}}\ls2\adjustright {You can use the }{\cs27\f2\fs20 odr_malloc()}{
 function (see section }{\field{\*\fldinst {HYPERLINK "yaz-5.html" \\l "odr-use"}{\fs20 {\*\datafield 
08d0c9ea79f9bace118c8200aa004ba90b02000000090000000303000000000000c00000000000004600000b00000079617a2d352e68746d6c00ffffadde000000000000000000000000000000000000000000000000080000006f00640072002d0075007300650000000000}}}{\fldrslt {\cs29\ul\cf2 Using ODR}}}
{ for details). When you use }{\cs27\f2\fs20 odr_malloc()}{, you can release all of the allocated data in a single operation, independent of any pointers and relations between the data. }{\cs27\f2\fs20 odr_malloc()}{
 is based on a "nibble-memory" scheme, in which large portions of memory are allocated, and then gradually handed out with each call to }{\cs27\f2\fs20 odr_malloc()}{. The next time you call }{\cs27\f2\fs20 odr_reset()}{
, all of the memory allocated since the last call is recycled for future use (actually, it is placed on a free-list). 
\par {\pntext\pard\plain\f3\fs22 \loch\af3\dbch\af0\hich\f3 \'b7\tab}}\pard \qj\fi-360\li720\sb100\sa100\nowidctlpar{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnindent360\pnhang{\pntxtb \'b7}}\ls2\adjustright {
You can combine all of the methods described here. This will often be the most practical approach. For instance, you might use }{\cs27\f2\fs20 odr_malloc()}{
 to allocate an entire structure and some of its elements, while you leave other elements pointing to global or per-session default variables. 
\par }\pard \qj\sb100\sa100\nowidctlpar{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright {The }{\b ASN}{ module provides an important aid in creating new PDUs. For each of the PDU types (say, }{\cs27\f2\fs20 Z_InitRequest}{
), a function is provided that allocates and initializes an instance of that PDU type for you. In the case of the InitRequest, the function is simply named }{\cs27\f2\fs20 zget_Initrequest()}{
, and it sets up reasonable default value for all of the mandatory 
members. The optional members are generally initialized to null pointers. This last aspect is very important: it ensures that if the PDU definitions are extended after you finish your implementation (to accommodate new versions of the protocol, say), you 
won't get into trouble with uninitialized pointers in your structures. The functions use }{\cs27\f2\fs20 odr_malloc()}{ to allocate the PDUs and its members, so you can free everything again with a single call to }{\cs27\f2\fs20 odr_reset()}{
. We strongly recommend that you use the }{\cs27\f2\fs20 zget_*}{ functions whenever you are preparing a PDU (in a C++ API, the }{\cs27\f2\fs20 zget_}{ functions would probably be promoted to constructors for the individual types).
\par The prototype for the individual PDU types generally look like this:
\par }\pard\plain \s32\qj\li360\ri360\nowidctlpar\tx0\tx959\tx1918\tx2877\tx3836\tx4795\tx5754\tx6713\tx7672\tx8631{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright \f2\fs20\lang2057 {\cs27 
\par Z_<type> *zget_<type>(ODR o);
\par }\pard\plain \qj\sb100\sa100\nowidctlpar{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright \fs22\lang2057 {eg.:
\par }\pard\plain \s32\qj\li360\ri360\nowidctlpar\tx0\tx959\tx1918\tx2877\tx3836\tx4795\tx5754\tx6713\tx7672\tx8631{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright \f2\fs20\lang2057 {\cs27 
\par Z_InitRequest *zget_InitRequest(ODR o);
\par }\pard\plain \qj\sb100\sa100\nowidctlpar{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright \fs22\lang2057 {The }{\b ODR}{ handle should generally be your encoding stream, but it needn't be.
\par As well as the individual PDU functions, a function }{\cs27\f2\fs20 zget_APDU()}{ is provided, which allocates a toplevel Z-APDU of the type requested:
\par }\pard\plain \s32\qj\li360\ri360\nowidctlpar\tx0\tx959\tx1918\tx2877\tx3836\tx4795\tx5754\tx6713\tx7672\tx8631{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright \f2\fs20\lang2057 {\cs27 
\par Z_APDU *zget_APDU(ODR o, Z_APDU_which which);
\par }\pard\plain \qj\sb100\sa100\nowidctlpar{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright \fs22\lang2057 {The }{\cs27\f2\fs20 which}{ parameter is (of course) the discriminator belonging to the }{\cs27\f2\fs20 Z_APDU}{
 CHOICE type. All of the interface described here is provided by the }{\b ASN}{ module, and you access it through the }{\cs27\f2\fs20 proto.h}{ header file.
\par }\pard\plain \s19\qj\sb100\sa100\keepn\nowidctlpar{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\outlinelevel2\adjustright \b\fs36\lang2057 {{\*\bkmkstart oid}{\*\bkmkstart ss3_3}{\*\bkmkstart _Toc399132420}{\*\bkmkend oid}3.3 Object Identifiers
{\*\bkmkend ss3_3}{\*\bkmkend _Toc399132420}
\par }\pard\plain \qj\sb100\sa100\nowidctlpar{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright \fs22\lang2057 {
When you refer to object identifiers in your application, you need to be aware that SR and Z39.50 use two different set of OIDs to refer to the same objects. To handle this easily, }{\b YAZ}{ provides a utility module to }{\b ASN}{
 which provides an internal representation of the OIDs used in both protocols. Each oid is described by a structure:
\par }\pard\plain \s32\qj\li360\ri360\nowidctlpar\tx0\tx959\tx1918\tx2877\tx3836\tx4795\tx5754\tx6713\tx7672\tx8631{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright \f2\fs20\lang2057 {\cs27 
\par typedef struct oident
\par \{
\par     enum oid_proto proto;
\par     enum oid_class class;
\par     enum oid_value value;
\par     char *desc;
\par \} oident;
\par }\pard\plain \qj\sb100\sa100\nowidctlpar{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright \fs22\lang2057 {The }{\cs27\f2\fs20 proto}{ field can be set to either }{\cs27\f2\fs20 PROTO_SR}{ or }{\cs27\f2\fs20 PROTO_Z3950}{. The }{\cs27\f2\fs20 class}{
 might be, say, }{\cs27\f2\fs20 CLASS_RECSYN}{, and the }{\cs27\f2\fs20 value}{ might be }{\cs27\f2\fs20 VAL_USMARC}{ for the USMARC record format. Functions
\par }\pard\plain \s32\qj\li360\ri360\nowidctlpar\tx0\tx959\tx1918\tx2877\tx3836\tx4795\tx5754\tx6713\tx7672\tx8631{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright \f2\fs20\lang2057 {\cs27 
\par Odr_oid *oid_getoidbyent(struct oident *ent);
\par struct oident *oid_getentbyoid(Odr_oid *o);
\par }\pard\plain \qj\sb100\sa100\nowidctlpar{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright \fs22\lang2057 {are provided to map between object identifiers and database entries. If you store a member of the }{\cs27\f2\fs20 oid_proto}{
 type in your association state information, it's a simple matter, at runtime, to generate the correct OID when you need it
. For decoding, you can simply ignore the proto field, or if you're strict, you can verify that your peer is using the OID family from the correct protocol. The }{\cs27\f2\fs20 desc}{
 field is a short, human-readable name for the PDU, useful mainly for diagnostic output.
\par }{\i NO
TE: Plans are underway to merge the two protocols into a single definition, with one set of object identifiers. When this happens, the oid module will no longer be required to support protocol independence, but it should still be useful as a simple OID da
tabase.}{
\par }\pard\plain \s19\qj\sb100\sa100\keepn\nowidctlpar{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\outlinelevel2\adjustright \b\fs36\lang2057 {{\*\bkmkstart ss3_4}{\*\bkmkstart _Toc399132421}3.4 EXTERNAL Data{\*\bkmkend ss3_4}{\*\bkmkend _Toc399132421}
\par }\pard\plain \qj\sb100\sa100\nowidctlpar{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright \fs22\lang2057 {
In order to achieve extensibility and adaptability to different application domains, the new version of the protocol defines many structures outside of the main ASN.1 specification, referencing t
hem through ASN.1 EXTERNAL constructs. To simplify the construction and access to the externally referenced data, the }{\b ASN}{ module defines a specialized version of the EXTERNAL construct, called }{\cs27\f2\fs20 Z_External}{. It is defined thus:

\par }\pard\plain \s32\qj\li360\ri360\nowidctlpar\tx0\tx959\tx1918\tx2877\tx3836\tx4795\tx5754\tx6713\tx7672\tx8631{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright \f2\fs20\lang2057 {\cs27 
\par typedef struct Z_External
\par \{
\par     Odr_oid *direct_reference;
\par     int *indirect_reference;
\par     char *descriptor;
\par     enum
\par     \{
\par         /* Generic types */
\par         Z_External_single = 0,
\par         Z_External_octet,
\par         Z_External_arbitrary,
\par 
\par         /* Specific types */
\par         Z_External_SUTRS,
\par         Z_External_explainRecord,
\par         Z_External_resourceReport1,
\par         Z_External_resourceReport2
\par 
\par         ...
\par 
\par     \} which;
\par     union
\par     \{
\par         /* Generic types */
\par         Odr_any *single_ASN1_type;
\par         Odr_oct *octet_aligned;
\par         Odr_bitmask *arbitrary;
\par 
\par         /* Specific types */
\par         Z_SUTRS *sutrs;
\par         Z_ExplainRecord *explainRecord;
\par         Z_ResourceReport1 *resourceReport1;
\par         Z_ResourceReport2 *resourceReport2;
\par 
\par         ...
\par 
\par     \} u;
\par \} Z_External;
\par }\pard\plain \qj\sb100\sa100\nowidctlpar{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright \fs22\lang2057 {When decoding, the }{\b ASN}{
 module will attempt to determine which syntax describes the data by looking at the reference fields (currently only the direct-reference). For ASN.1 structured data, you need only consult the }{\cs27\f2\fs20 which}{ field to determine the
 type of data. You can the access the data directly through the union. When constructing data for encoding, you set the union pointer to point to the data, and set the }{\cs27\f2\fs20 which}{
 field accordingly. Remember also to set the direct (or indirect) reference to the correct OID for the data type. For non-ASN.1 data such as MARC records, use the }{\cs27\f2\fs20 octet_aligned}{ arm of the union.
\par Some servers return ASN.1 structured data values (eg. database records) as BER-encoded records placed in the }{\cs27\f2\fs20 octet-aligned}{ branch of the EXTERNAL CHOICE. The ASN-module will }{\i not}{
 automatically decode these records. To help you decode the records in the application, the function
\par }\pard\plain \s32\qj\li360\ri360\nowidctlpar\tx0\tx959\tx1918\tx2877\tx3836\tx4795\tx5754\tx6713\tx7672\tx8631{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright \f2\fs20\lang2057 {\cs27 
\par Z_ext_typeent *z_ext_gettypebyref(oid_value ref);
\par }\pard\plain \qj\sb100\sa100\nowidctlpar{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright \fs22\lang2057 {Can be used to retrieve information about the known, external data type
s. The function return a pointer to a static area, or NULL, if no match for the given direct reference is found. The }{\cs27\f2\fs20 Z_ext_typeent}{ is defined as:
\par }\pard\plain \s32\qj\li360\ri360\nowidctlpar\tx0\tx959\tx1918\tx2877\tx3836\tx4795\tx5754\tx6713\tx7672\tx8631{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright \f2\fs20\lang2057 {\cs27 
\par typedef struct Z_ext_typeent
\par \{
\par     oid_value dref;    /* the direct-reference OID value. */
\par     int what;          /* discriminator value for the external CHOICE */
\par     Odr_fun fun;       /* decoder function */
\par \} Z_ext_typeent;
\par }\pard\plain \qj\sb100\sa100\nowidctlpar{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright \fs22\lang2057 {The }{\cs27\f2\fs20 what}{
 member contains the Z_External union discriminator value for the given type: For the SUTRS record syntax, the value would be }{\cs27\f2\fs20 Z_External_sutrs}{. The }{\cs27\f2\fs20 fun}{
 member contains a pointer to the function which encodes/decodes the given type. Again, for the SUTRS record syntax, the value of }{\cs27\f2\fs20 fun}{ would be }{\cs27\f2\fs20 z_SUTRS}{ (a function pointer).
\par If you receive an EXTERNAL which contains an octet-string value that you suspect of being an ASN.1-structured data value, you can use }{\cs27\f2\fs20 z_ext_gettypebyref}{
 to look for the provided direct-reference. If the return value is different from NULL, you can use the provided function to decode the BER string (see section }{\field{\*\fldinst {HYPERLINK "yaz-5.html" \\l "odr-use"}{\fs20 {\*\datafield 
08d0c9ea79f9bace118c8200aa004ba90b02000000090000000303000000000000c00000000000004600000b00000079617a2d352e68746d6c00ffffadde000000000000000000000000000000000000000000000000080000006f00640072002d0075007300650000000000}}}{\fldrslt {\cs29\ul\cf2 Using ODR}}}
{). 
\par If you want to }{\i send}{ EXTERNALs containing ASN.1-structured values in the occtet-aligned branch of the CHOICE, this is possible too. However, on the encoding phase, it requires a somewhat involved juggling around of the various buffers involved.

\par If you need to add new, externally defined data types, you must update the struct above, in the source file }{\cs27\f2\fs20 prt-ext.h}{, as well as the encoder/decoder in the file }{\cs27\f2\fs20 prt-ext.c}{
. When changing the latter, remember to update both the }{\cs27\f2\fs20 arm}{ arrary and the list }{\cs27\f2\fs20 type_table}{, which drives the CHOICE biasing that is necessary to tell the different, structured types apart on decoding.
\par }{\i NOTE: Eventually, the EXTERNAL processing will most likely automatically insert the correct OIDs or indire
ct-refs. First, however, we need to determine how application-context management (specifically the presentation-context-list) should fit into the various modules.}{
\par }\pard\plain \s19\qj\sb100\sa100\keepn\nowidctlpar{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\outlinelevel2\adjustright \b\fs36\lang2057 {{\*\bkmkstart ss3_5}{\*\bkmkstart _Toc399132422}3.5 PDU Contents Table{\*\bkmkend ss3_5}{\*\bkmkend _Toc399132422}

\par }\pard\plain \qj\sb100\sa100\nowidctlpar{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright \fs22\lang2057 {We include, for reference, a listing of the fields of each top-level PDU, as well as their default settings.
\par }\pard\plain \s32\qj\nowidctlpar\tx0\tx959\tx1918\tx2877\tx3836\tx4795\tx5754\tx6713\tx7672\tx8631{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright \f2\fs20\lang2057 {
\par Z_InitRequest
\par -------------
\par Field                        Type                Default value
\par 
\par referenceId                  Z_ReferenceId       NULL
\par protocolVersion              Odr_bitmask         Empty bitmask
\par options                      Odr_bitmask         Empty bitmask
\par preferredMessageSize         int                 30*1024
\par maximumRecordSize            int                 30*1024
\par idAuthentication             Z_IdAuthentication  NULL
\par implementationId             char*               "YAZ"
\par implementationName           char*               "Index Data/YAZ"
\par implementationVersion        char*               YAZ_VERSION
\par userInformationField         Z_UserInformation   NULL
\par otherInfo                    Z_OtherInformation  NULL
\par 
\par Z_InitResponse
\par --------------
\par Field                        Type                Default value
\par 
\par referenceId                  Z_ReferenceId       NULL
\par protocolVersion              Odr_bitmask         Empty bitmask
\par options                      Odr_bitmask         Empty bitmask
\par preferredMessageSize         int                 30*1024
\par maximumRecordSize            int                 30*1024
\par result                       bool_t              TRUE
\par implementationId             char*               "YAZ"
\par implementationName           char*               "Index Data/YAZ"
\par implementationVersion        char*               YAZ_VERSION
\par userInformationField         Z_UserInformat..    NULL
\par otherInfo                    Z_OtherInformation  NULL
\par 
\par Z_SearchRequest
\par ---------------
\par Field                        Type                Default value
\par 
\par referenceId                  Z_ReferenceId       NULL
\par smallSetUpperBound           int                 0
\par largeSetLowerBound           int                 1
\par mediumSetPresentNumber       int                 0
\par replaceIndicator             bool_t              TRUE
\par resultSetName                char*               "Default"
\par num_databaseNames            int                 0
\par databaseNames                char**              NULL
\par smallSetElementSetNames      Z_ElementSetNames   NULL
\par mediumSetElementSetNames     Z_ElementSetNames   NULL
\par preferredRecordSyntax        Odr_oid             NULL
\par query                        Z_Query             NULL
\par additionalSearchInfo         Z_OtherInformation  NULL
\par otherInfo                    Z_OtherInformation  NULL
\par 
\par Z_SearchResponse
\par ----------------
\par Field                        Type                Default value
\par 
\par referenceId                  Z_ReferenceId       NULL
\par resultCount                  int                 0
\par numberOfRecordsReturned      int                 0
\par nextResultSetPosition        int                 0
\par searchStatus                 bool_t              TRUE
\par resultSetStatus              int                 NULL
\par presentStatus                int                 NULL
\par records                      Z_Records           NULL
\par additionalSearchInfo         Z_OtherInformation  NULL
\par otherInfo                    Z_OtherInformation  NULL
\par 
\par Z_PresentRequest
\par ----------------
\par Field                        Type                Default value
\par 
\par referenceId                  Z_ReferenceId       NULL
\par resultSetId                  char*               "Default"
\par resultSetStartPoint          int                 1
\par numberOfRecordsRequested     int                 10
\par num_ranges                   int                 0
\par additionalRanges             Z_Range             NULL
\par recordComposition            Z_RecordComposition NULL
\par preferredRecordSyntax        Odr_oid             NULL
\par maxSegmentCount              int                 NULL
\par maxRecordSize                int                 NULL
\par maxSegmentSize               int                 NULL
\par otherInfo                    Z_OtherInformation  NULL
\par 
\par Z_PresentResponse
\par -----------------
\par Field                        Type                Default value
\par 
\par referenceId                  Z_ReferenceId       NULL
\par numberOfRecordsReturned      int                 0
\par nextResultSetPosition        int                 0
\par presentStatus                int                 Z_PRES_SUCCESS
\par records                      Z_Records           NULL
\par otherInfo                    Z_OtherInformation  NULL
\par 
\par Z_DeleteResultSetRequest
\par ------------------------
\par Field                        Type                Default value
\par 
\par referenceId                  Z_ReferenceId       NULL
\par deleteFunction               int                 Z_DeleteRequest_list
\par num_ids                      int                 0
\par resultSetList                char**              NULL
\par otherInfo                    Z_OtherInformation  NULL
\par 
\par Z_DeleteResultSetResponse
\par -------------------------
\par Field                        Type                Default value
\par 
\par referenceId                  Z_ReferenceId       NULL
\par deleteOperationStatus        int                 Z_DeleteStatus_success
\par num_statuses                 int                 0
\par deleteListStatuses           Z_ListStatus**      NULL
\par numberNotDeleted             int                 NULL
\par num_bulkStatuses             int                 0
\par bulkStatuses                 Z_ListStatus        NULL
\par deleteMessage                char*               NULL
\par otherInfo                    Z_OtherInformation  NULL
\par 
\par Z_ScanRequest
\par -------------
\par Field                        Type                Default value
\par 
\par referenceId                  Z_ReferenceId       NULL
\par num_databaseNames            int                 0
\par databaseNames                char**              NULL
\par attributeSet                 Odr_oid             NULL
\par termListAndStartPoint        Z_AttributesPlus... NULL
\par stepSize                     int                 NULL
\par numberOfTermsRequested       int                 20
\par preferredPositionInResponse  int                 NULL
\par otherInfo                    Z_OtherInformation  NULL
\par 
\par Z_ScanResponse
\par --------------
\par Field                        Type                Default value
\par 
\par referenceId                  Z_ReferenceId       NULL
\par stepSize                     int                 NULL
\par scanStatus                   int                 Z_Scan_success
\par numberOfEntriesReturned      int                 0
\par positionOfTerm               int                 NULL
\par entries                      Z_ListEntris        NULL
\par attributeSet                 Odr_oid             NULL
\par otherInfo                    Z_OtherInformation  NULL
\par 
\par Z_TriggerResourceControlRequest
\par -------------------------------
\par Field                        Type                Default value
\par 
\par referenceId                  Z_ReferenceId       NULL
\par requestedAction              int                 Z_TriggerResourceCtrl_resou..
\par prefResourceReportFormat     Odr_oid             NULL
\par resultSetWanted              bool_t              NULL
\par otherInfo                    Z_OtherInformation  NULL
\par 
\par Z_ResourceControlRequest
\par ------------------------
\par Field                        Type                Default value
\par 
\par referenceId                  Z_ReferenceId       NULL
\par suspendedFlag                bool_t              NULL
\par resourceReport               Z_External          NULL
\par partialResultsAvailable      int                 NULL
\par responseRequired             bool_t              FALSE
\par triggeredRequestFlag         bool_t              NULL
\par otherInfo                    Z_OtherInformation  NULL
\par 
\par Z_ResourceControlResponse
\par -------------------------
\par Field                        Type                Default value
\par 
\par referenceId                  Z_ReferenceId       NULL
\par continueFlag                 bool_t              TRUE
\par resultSetWanted              bool_t              NULL
\par otherInfo                    Z_OtherInformation  NULL
\par 
\par Z_AccessControlRequest
\par ----------------------
\par Field                        Type                Default value
\par 
\par referenceId                  Z_ReferenceId       NULL
\par which                        enum                Z_AccessRequest_simpleForm;
\par u                            union               NULL
\par otherInfo                    Z_OtherInformation  NULL
\par 
\par Z_AccessControlResponse
\par -----------------------
\par Field                        Type                Default value
\par 
\par referenceId                  Z_ReferenceId       NULL
\par which                        enum                Z_AccessResponse_simpleForm
\par u                            union               NULL
\par diagnostic                   Z_DiagRec           NULL
\par otherInfo                    Z_OtherInformation  NULL
\par 
\par Z_Segment
\par ---------
\par Field                        Type                Default value
\par 
\par referenceId                  Z_ReferenceId       NULL
\par numberOfRecordsReturned      int                 value=0
\par num_segmentRecords           int                 0
\par segmentRecords               Z_NamePlusRecord    NULL
\par otherInfo                    Z_OtherInformation  NULL
\par 
\par Z_Close
\par -------
\par Field                        Type                Default value
\par 
\par referenceId                  Z_ReferenceId       NULL
\par closeReason                  int                 Z_Close_finished
\par diagnosticInformation        char*               NULL
\par resourceReportFormat         Odr_oid             NULL
\par resourceFormat               Z_External          NULL
\par otherInfo                    Z_OtherInformation  NULL
\par }\pard\plain \qj\sb100\sa100\nowidctlpar{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright \fs22\lang2057 {
\par }\pard\plain \s19\qj\sb100\sa100\keepn\nowidctlpar{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\outlinelevel2\adjustright \b\fs36\lang2057 {{\*\bkmkstart s4}{\*\bkmkstart _Toc399132423}4. Supporting Tools{\*\bkmkend s4}{\*\bkmkend _Toc399132423}
\par }\pard\plain \qj\sb100\sa100\nowidctlpar{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright \fs22\lang2057 {
In support of the service API - primarily the ASN module, which provides the programmatic interface to the Z39.50 APDUs, YAZ contains a collection of tools that support the development of applications.
\par }\pard\plain \s19\qj\sb100\sa100\keepn\nowidctlpar{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\outlinelevel2\adjustright \b\fs36\lang2057 {{\*\bkmkstart ss4_1}{\*\bkmkstart _Toc399132424}4.1 Query Syntax Parsers{\*\bkmkend ss4_1}{\*\bkmkend _Toc399132424}

\par }\pard\plain \qj\sb100\sa100\nowidctlpar{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright \fs22\lang2057 {
Since the type-1 (RPN) query structure has no direct, useful string representation, every origin application needs to provide some form of mapping from a local query notation or representation to a }{\cs27\f2\fs20 Z_RPNQuery}{
 structure. Some programmers will prefer to construct the query manually, perhaps using }{\cs27\f2\fs20 odr_malloc()}{ to simplify memory management. The YAZ distribution includes two separate, query-generating tools that may be of use to you.
\par }\pard\plain \s20\qj\sb100\sa100\keepn\nowidctlpar{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\outlinelevel3\adjustright \b\fs28\lang2057 {Prefix Query Format
\par }\pard\plain \qj\sb100\sa100\nowidctlpar{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright \fs22\lang2057 {
Since RPN or reverse polish notation is really just a fancy way of describing a suffix notation format (operator follows operands), it would seem that the confusion is total when we now introduce a prefix notation for RPN. The rea
son is one of simple laziness - it's somewhat simpler to interpret a prefix format, and this utility was designed for maximum simplicity, to provide a baseline representation for use in simple test applications and scripting environments (like Tcl). The d
emonstration client included with YAZ uses the PQF.
\par The PQF is defined by the pquery module in the YAZ library. The }{\cs27\f2\fs20 pquery.h}{ file provides the declaration of the functions
\par }\pard\plain \s32\qj\li360\ri360\nowidctlpar\tx0\tx959\tx1918\tx2877\tx3836\tx4795\tx5754\tx6713\tx7672\tx8631{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright \f2\fs20\lang2057 {\cs27 
\par Z_RPNQuery *p_query_rpn (ODR o, oid_proto proto, const char *qbuf);
\par 
\par Z_AttributesPlusTerm *p_query_scan (ODR o, oid_proto proto,
\par       Odr_oid **attributeSetP, const char *qbuf);
\par 
\par int p_query_attset (const char *arg);
\par }\pard\plain \qj\sb100\sa100\nowidctlpar{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright \fs22\lang2057 {The function }{\cs27\f2\fs20 p_query_rpn()}{ takes as arguments an }{\b ODR}{ stream (see section }{\field{\*\fldinst {HYPERLINK "yaz-5.html" 
\\l "odr"}{\fs20 {\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000090000000303000000000000c00000000000004600000b00000079617a2d352e68746d6c00ffffadde000000000000000000000000000000000000000000000000040000006f006400720000000000}}}{\fldrslt {
\cs29\ul\cf2 The ODR Module}}}{) to provide a memory source (the structure created is released on the next call to }{\cs27\f2\fs20 odr_reset()}{ on the stream/), a protocol identifier (one of the constants }{\cs27\f2\fs20 PROTO_Z3950}{ and }{
\cs27\f2\fs20 PROTO_SR}{), an attribute set reference, and finally a null-terminated string holding the query string.
\par If the parse went well, }{\cs27\f2\fs20 p_query_rpn()}{ returns a pointer to a }{\cs27\f2\fs20 Z_RPNQuery}{ structure which can be placed directly into a }{\cs27\f2\fs20 Z_SearchRequest}{.
\par The }{\cs27\f2\fs20 p_query_attset}{ specifies which attribute set to use if the query doesn't specify one by the }{\cs27\f2\fs20 @attrset}{ operator. The }{\cs27\f2\fs20 p_query_attset}{
 returns 0 if the argument is a valid attribute set specifier; otherwise the function returns -1.
\par The grammar of the PQF is as follows:
\par }\pard\plain \s32\qj\li360\ri360\nowidctlpar\tx0\tx959\tx1918\tx2877\tx3836\tx4795\tx5754\tx6713\tx7672\tx8631{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright \f2\fs20\lang2057 {\cs27 
\par Query ::= [ AttSet ] QueryStruct.
\par 
\par AttSet ::= string.
\par 
\par QueryStruct ::= \{ Attribute \} Simple | Complex.
\par 
\par Attribute ::= '@attr' AttributeType '=' AttributeValue.
\par 
\par AttributeType ::= integer.
\par 
\par AttributeValue ::= integer.
\par 
\par Complex ::= Operator QueryStruct QueryStruct.
\par 
\par Operator ::= '@and' | '@or' | '@not' | '@prox' Proximity.
\par 
\par Simple ::= ResultSet | Term.
\par 
\par ResultSet ::= '@set' string.
\par 
\par Term ::= string | '"' string '"'.
\par 
\par Proximity ::= Exclusion Distance Ordered Relation WhichCode UnitCode.
\par 
\par Exclusion ::= '1' | '0' | 'void'.
\par 
\par Distance ::= integer.
\par 
\par Ordered ::= '1' | '0'.
\par 
\par Relation ::= integer.
\par 
\par WhichCode ::= 'known' | 'private' | integer.
\par 
\par UnitCode ::= integer.
\par }\pard\plain \qj\sb100\sa100\nowidctlpar{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright \fs22\lang2057 {You will note that the syntax above is a fairly faithful representation of RPN, except for the }{\cs27\f2\fs20 Attibute}{
, which has been moved a step away from the term, allowing you to associate one or more attributes with an entire query structure. The parser will automatically apply the given attributes to each term as required.
\par The following are all examples of valid queries in the PQF.
\par }\pard\plain \s32\qj\li360\ri360\nowidctlpar\tx0\tx959\tx1918\tx2877\tx3836\tx4795\tx5754\tx6713\tx7672\tx8631{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright \f2\fs20\lang2057 {\cs27 
\par dylan
\par 
\par "bob dylan"
\par 
\par @or "dylan" "zimmerman"
\par 
\par @set Result-1
\par 
\par @or @and bob dylan @set Result-1
\par 
\par @attr 4=1 @and @attr 1=1 "bob dylan" @attr 1=4 "slow train coming"
\par 
\par @attr 4=1 @attr 1=4 "self portrait"
\par 
\par @prox 0 3 1 2 k 2 dylan zimmerman
\par }\pard\plain \s20\qj\sb100\sa100\keepn\nowidctlpar{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\outlinelevel3\adjustright \b\fs28\lang2057 {Common Command Language
\par }\pard\plain \qj\sb100\sa100\nowidctlpar{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright \fs22\lang2057 {
Not all users enjoy typing in prefix query structures and numerical attribute values, even in a minimalistic test client. In the library world, the more intuitive Common Command Language (or ISO 8777) has enjoyed some popularity - especially before the wi
despread availability of graphical interfaces. It is still useful in applications where you for some reason or other need to provide a symbolic language for expressing boolean query structures.
\par The EUROPAGATE research project working under the Libraries pro
gramme of the European Commission's DG XIII has, amongst other useful tools, implemented a general-purpose CCL parser which produces an output structure that can be trivially converted to the internal RPN representation of YAZ (The }{\cs27\f2\fs20 
Z_RPNQuery}{ structure). Since the CCL utility - along with the rest of the software produced by EUROPAGATE - is made freely available on a liberal license, it is included as a supplement to YAZ.
\par }\pard\plain \s20\qj\sb100\sa100\keepn\nowidctlpar{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\outlinelevel3\adjustright \b\fs28\lang2057 {CCL Syntax
\par }\pard\plain \qj\sb100\sa100\nowidctlpar{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright \fs22\lang2057 {The CCL parser obeys the following grammar for the FIND argument. The syntax is annotated by in the lines prefixed by }{\cs27\f2\fs20 --}{.

\par }\pard\plain \s32\qj\li360\ri360\nowidctlpar\tx0\tx959\tx1918\tx2877\tx3836\tx4795\tx5754\tx6713\tx7672\tx8631{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright \f2\fs20\lang2057 {\cs27 
\par CCL-Find ::= CCL-Find Op Elements
\par            | Elements.
\par 
\par Op ::= "and" | "or" | "not"
\par -- The above means that Elements are separated by boolean operators.
\par 
\par Elements ::= '(' CCL-Find ')'
\par            | Set
\par            | Terms
\par            | Qualifiers Relation Terms
\par            | Qualifiers Relation '(' CCL-Find ')'
\par            | Qualifiers '=' string '-' string
\par -- Elements is either a recursive definition, a result set reference, a
\par -- list of terms, qualifiers followed by terms, qualifiers followed
\par -- by a recursive definition or qualifiers in a range (lower - upper).
\par 
\par Set ::= 'set' = string
\par -- Reference to a result set
\par 
\par Terms ::= Terms Prox Term
\par         | Term
\par -- Proximity of terms.
\par 
\par Term ::= Term string
\par        | string
\par -- This basically means that a term may include a blank
\par 
\par Qualifiers ::= Qualifiers ',' string
\par              | string
\par -- Qualifiers is a list of strings separated by comma
\par 
\par Relation ::= '=' | '>=' | '<=' | '<>' | '>' | '<'
\par -- Relational operators. This really doesn't follow the ISO8777
\par -- standard.
\par 
\par Prox ::= '%' | '!'
\par -- Proximity operator
\par }\pard\plain \qj\sb100\sa100\nowidctlpar{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright \fs22\lang2057 {The following queries are all valid:
\par }\pard\plain \s32\qj\li360\ri360\nowidctlpar\tx0\tx959\tx1918\tx2877\tx3836\tx4795\tx5754\tx6713\tx7672\tx8631{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright \f2\fs20\lang2057 {\cs27 
\par dylan
\par 
\par "bob dylan"
\par 
\par dylan or zimmerman
\par 
\par set=1
\par 
\par (dylan and bob) or set=1
\par }\pard\plain \qj\sb100\sa100\nowidctlpar{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright \fs22\lang2057 {Assuming that the qualifiers }{\cs27\f2\fs20 ti}{, }{\cs27\f2\fs20 au}{ and }{\cs27\f2\fs20 date}{ are defined we may use: 
\par }\pard\plain \s32\qj\li360\ri360\nowidctlpar\tx0\tx959\tx1918\tx2877\tx3836\tx4795\tx5754\tx6713\tx7672\tx8631{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright \f2\fs20\lang2057 {\cs27 
\par ti=self portrait
\par 
\par au=(bob dylan and slow train coming)
\par 
\par date>1980 and (ti=((self portrait)))
\par }\pard\plain \s20\qj\sb100\sa100\keepn\nowidctlpar{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\outlinelevel3\adjustright \b\fs28\lang2057 {CCL Qualifiers
\par }\pard\plain \qj\sb100\sa100\nowidctlpar{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright \fs22\lang2057 {
Qualifiers are used to direct the search to a particular searchable index, such as title (ti) and author indexes (au). The CCL standard itself doesn't specify a particular set of qualifiers, but it does suggest a few short-hand notations. You can customiz
e
 the CCL parser to support a particular set of qualifiers to relect the current target profile. Traditionally, a qualifier would map to a particular use-attribute within the BIB-1 attribute set. However, you could also define qualifiers that would set, fo
r example, the structure-attribute.
\par Consider a scenario where the target support ranked searches in the title-index. In this case, the user could specify 
\par }\pard\plain \s32\qj\li360\ri360\nowidctlpar\tx0\tx959\tx1918\tx2877\tx3836\tx4795\tx5754\tx6713\tx7672\tx8631{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright \f2\fs20\lang2057 {\cs27 
\par ti,ranked=knuth computer
\par }\pard\plain \qj\sb100\sa100\nowidctlpar{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright \fs22\lang2057 {and the }{\cs27\f2\fs20 ranked}{ would map to structure=free-form-text (4=105) and the }{\cs27\f2\fs20 ti}{ would map to title (1=4).
\par A "profile" with a set predefined CCL qualifiers can be read from a file. The YAZ client reads its CCL qualifiers from a file named }{\cs27\f2\fs20 default.bib}{. Each line in the file has the form:
\par }{\i qualifier-name}{ }{\i type}{=}{\i val}{ }{\i type}{=}{\i val}{ ...
\par where }{\i qualifier-name}{ is the name of the qualifier to be used (eg. }{\cs27\f2\fs20 ti}{), }{\i type}{ is a BIB-1 category type and }{\i val}{ is the corresponding BIB-1 attribute value. The }{\i type}{ can be either numeric or it may be either }{
\cs27\f2\fs20 u}{ (use), }{\cs27\f2\fs20 r}{ (relation), }{\cs27\f2\fs20 p}{ (position), }{\cs27\f2\fs20 s}{ (structure), }{\cs27\f2\fs20 t}{ (truncation) or }{\cs27\f2\fs20 c}{ (completeness). The }{\i qualifier-name}{ }{\cs27\f2\fs20 term}{
 has a special meaning. The types and values for this definition is used when }{\i no}{ qualifier is present.
\par Consider the following definition: 
\par }\pard\plain \s32\qj\li360\ri360\nowidctlpar\tx0\tx959\tx1918\tx2877\tx3836\tx4795\tx5754\tx6713\tx7672\tx8631{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright \f2\fs20\lang2057 {\cs27 
\par ti       u=4 s=1
\par au       u=1 s=1
\par term     s=105
\par }\pard\plain \qj\sb100\sa100\nowidctlpar{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright \fs22\lang2057 {Two qualifiers are defined, }{\cs27\f2\fs20 ti}{ and }{\cs27\f2\fs20 au}{. They both set the structure-attribute to phrase (1). }{
\cs27\f2\fs20 ti}{ sets the use-attribute to 4. }{\cs27\f2\fs20 au}{ sets the use-attribute to 1. When no qualifiers are used in the query the structure-attribute is set to free-form-text (105).
\par }\pard\plain \s20\qj\sb100\sa100\keepn\nowidctlpar{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\outlinelevel3\adjustright \b\fs28\lang2057 {CCL API
\par }\pard\plain \qj\sb100\sa100\nowidctlpar{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright \fs22\lang2057 {All public definitions can be found in the header file }{\cs27\f2\fs20 ccl.h}{. A profile identifier is of type }{\cs27\f2\fs20 CCL_bibset}{
. A profile must be created with the call to the function }{\cs27\f2\fs20 ccl_qual_mk}{ which returns a profile handle of type }{\cs27\f2\fs20 CCL_bibset}{.
\par To read a file containing qualifier definitions the function }{\cs27\f2\fs20 ccl_qual_file}{ may be convenient. This function takes an already opened }{\cs27\f2\fs20 FILE}{ handle pointer as argument along with a }{\cs27\f2\fs20 CCL_bibset}{ handle.

\par To parse a simple string with a FIND query use the function 
\par }\pard\plain \s32\qj\li360\ri360\nowidctlpar\tx0\tx959\tx1918\tx2877\tx3836\tx4795\tx5754\tx6713\tx7672\tx8631{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright \f2\fs20\lang2057 {\cs27 
\par struct ccl_rpn_node *ccl_find_str (CCL_bibset bibset, const char *str,
\par                                    int *error, int *pos);
\par }\pard\plain \qj\sb100\sa100\nowidctlpar{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright \fs22\lang2057 {which takes the CCL profile (}{\cs27\f2\fs20 bibset}{) and query (}{\cs27\f2\fs20 str}{
) as input. Upon successful completion the RPN tree is returned. If an error eccur, such as a syntax error, the integer pointed to by }{\cs27\f2\fs20 error}{ holds the error code and }{\cs27\f2\fs20 pos}{
 holds the offset inside query string in which the parsing failed.
\par An english representation of the error may be obtained by calling the }{\cs27\f2\fs20 ccl_err_msg}{ function. The error codes are listed in }{\cs27\f2\fs20 ccl.h}{.
\par To convert the CCL RPN tree (type }{\cs27\f2\fs20 struct ccl_rpn_node *}{) to the Z_RPNQuery of YAZ the function }{\cs27\f2\fs20 ccl_rpn_query}{ must be used. This function which is part of YAZ is implemented in }{\cs27\f2\fs20 yaz-ccl.c}{
. After calling this function the CCL RPN tree is probably no longer needed. The }{\cs27\f2\fs20 ccl_rpn_delete}{ destroys the CCL RPN tree.
\par A CCL profile may be destroyed by calling the }{\cs27\f2\fs20 ccl_qual_rm}{ function.
\par The token names for the CCL operators may be changed by setting the globals (all type }{\cs27\f2\fs20 char *}{) }{\cs27\f2\fs20 ccl_token_and}{, }{\cs27\f2\fs20 ccl_token_or}{, }{\cs27\f2\fs20 ccl_token_not}{ and }{\cs27\f2\fs20 ccl_token_set}{
. An operator may have aliases, i.e. there may be more than one name for the operator. To do this, separate each alias with a space character.
\par }\pard\plain \s19\qj\sb100\sa100\keepn\nowidctlpar{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\outlinelevel2\adjustright \b\fs36\lang2057 {{\*\bkmkstart ss4_2}{\*\bkmkstart _Toc399132425}4.2 Object Identifiers{\*\bkmkend ss4_2}{\*\bkmkend _Toc399132425}

\par }\pard\plain \qj\sb100\sa100\nowidctlpar{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright \fs22\lang2057 {The basic YAZ representation of an OID is an array of integers, terminated with the value -1. The }{\b ODR}{
 module provides two utility-functions to create and copy this type of data elements:
\par }\pard\plain \s32\qj\li360\ri360\nowidctlpar\tx0\tx959\tx1918\tx2877\tx3836\tx4795\tx5754\tx6713\tx7672\tx8631{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright \f2\fs20\lang2057 {\cs27 
\par Odr_oid *odr_getoidbystr(ODR o, char *str);
\par }\pard\plain \qj\sb100\sa100\nowidctlpar{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright \fs22\lang2057 {Creates an OID based on a string-based representation using dots (.) to separate elements in the OID.
\par }\pard\plain \s32\qj\li360\ri360\nowidctlpar\tx0\tx959\tx1918\tx2877\tx3836\tx4795\tx5754\tx6713\tx7672\tx8631{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright \f2\fs20\lang2057 {\cs27 
\par Odr_oid *odr_oiddup(ODR odr, Odr_oid *o);
\par }\pard\plain \qj\sb100\sa100\nowidctlpar{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright \fs22\lang2057 {Creates a copy of the OID referenced by the }{\i o}{ parameter. Both functions take an }{\b ODR}{
 stream as parameter. This stream is used to allocate memory for the data elements, which is released on a subsequent call to }{\cs27\f2\fs20 odr_reset()}{ on that stream.
\par The }{\b OID}{ module provides a higher-level representation of the family of object identifers which describe the Z39.50 protocol and its related objects. The definition of the module interface is given in the }{\cs27\f2\fs20 oid.h}{ file.
\par The interface is mainly based on the }{\cs27\f2\fs20 oident}{ structure. The definition of this structure looks like this:
\par }\pard\plain \s32\qj\li360\ri360\nowidctlpar\tx0\tx959\tx1918\tx2877\tx3836\tx4795\tx5754\tx6713\tx7672\tx8631{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright \f2\fs20\lang2057 {\cs27 
\par typedef struct oident
\par \{
\par     oid_proto proto;
\par     oid_class oclass;
\par     oid_value value;
\par     int oidsuffix[20];
\par     char *desc;
\par \} oident;
\par }\pard\plain \qj\sb100\sa100\nowidctlpar{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright \fs22\lang2057 {The }{\i proto}{ field takes one of the values
\par }\pard\plain \s32\qj\li360\ri360\nowidctlpar\tx0\tx959\tx1918\tx2877\tx3836\tx4795\tx5754\tx6713\tx7672\tx8631{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright \f2\fs20\lang2057 {\cs27 
\par PROTO_Z3950
\par PROTO_SR
\par }\pard\plain \qj\sb100\sa100\nowidctlpar{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright \fs22\lang2057 {
If you don't care about talking to SR-based implementations (few exist, and they may become fewer still if and when the ISO SR and ANSI Z39.50 documents are merged into a single standard), you can ignore this field on incoming packages, and always set it 
to PROTO_Z3950 for outgoing packages.
\par The }{\i oclass}{ field takes one of the values
\par }\pard\plain \s32\qj\li360\ri360\nowidctlpar\tx0\tx959\tx1918\tx2877\tx3836\tx4795\tx5754\tx6713\tx7672\tx8631{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright \f2\fs20\lang2057 {\cs27 
\par CLASS_APPCTX
\par CLASS_ABSYN
\par CLASS_ATTSET
\par CLASS_TRANSYN
\par CLASS_DIAGSET
\par CLASS_RECSYN
\par CLASS_RESFORM
\par CLASS_ACCFORM
\par CLASS_EXTSERV
\par CLASS_USERINFO
\par CLASS_ELEMSPEC
\par CLASS_VARSET
\par CLASS_SCHEMA
\par CLASS_TAGSET
\par }\pard\plain \qj\sb100\sa100\nowidctlpar{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright \fs22\lang2057 {corresponding to the OID classes defined by the Z39.50 standard.
\par Finally, the }{\i value}{ field takes one of the values
\par }\pard\plain \s32\qj\li360\ri360\nowidctlpar\tx0\tx959\tx1918\tx2877\tx3836\tx4795\tx5754\tx6713\tx7672\tx8631{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright \f2\fs20\lang2057 {\cs27 
\par VAL_APDU
\par VAL_BER
\par VAL_BASIC_CTX
\par VAL_BIB1
\par VAL_EXP1
\par VAL_EXT1
\par VAL_CCL1
\par VAL_GILS
\par VAL_WAIS
\par VAL_STAS
\par VAL_DIAG1
\par VAL_ISO2709
\par VAL_UNIMARC
\par VAL_INTERMARC
\par VAL_CCF
\par VAL_USMARC
\par VAL_UKMARC
\par VAL_NORMARC
\par VAL_LIBRISMARC
\par VAL_DANMARC
\par VAL_FINMARC
\par VAL_MAB
\par VAL_CANMARC
\par VAL_SBN
\par VAL_PICAMARC
\par VAL_AUSMARC
\par VAL_IBERMARC
\par VAL_EXPLAIN
\par VAL_SUTRS
\par VAL_OPAC
\par VAL_SUMMARY
\par VAL_GRS0
\par VAL_GRS1
\par VAL_EXTENDED
\par VAL_RESOURCE1
\par VAL_RESOURCE2
\par VAL_PROMPT1
\par VAL_DES1
\par VAL_KRB1
\par VAL_PRESSET
\par VAL_PQUERY
\par VAL_PCQUERY
\par VAL_ITEMORDER
\par VAL_DBUPDATE
\par VAL_EXPORTSPEC
\par VAL_EXPORTINV
\par VAL_NONE
\par VAL_SETM
\par VAL_SETG
\par VAL_VAR1
\par VAL_ESPEC1
\par }\pard\plain \qj\sb100\sa100\nowidctlpar{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright \fs22\lang2057 {again, corresponding to the specific OIDs defined by the standard.
\par The }{\i desc}{ field contains a brief, mnemonic name for the OID in question.
\par The function
\par }\pard\plain \s32\qj\li360\ri360\nowidctlpar\tx0\tx959\tx1918\tx2877\tx3836\tx4795\tx5754\tx6713\tx7672\tx8631{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright \f2\fs20\lang2057 {\cs27 
\par struct oident *oid_getentbyoid(int *o);
\par }\pard\plain \qj\sb100\sa100\nowidctlpar{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright \fs22\lang2057 {takes as argument an OID, and returns a pointer to a static area containing an }{\cs27\f2\fs20 oident}{
 structure. You typically use this function when you receive a PDU containing an OID, and you wish to branch out depending on the specific OID value.
\par The function
\par }\pard\plain \s32\qj\li360\ri360\nowidctlpar\tx0\tx959\tx1918\tx2877\tx3836\tx4795\tx5754\tx6713\tx7672\tx8631{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright \f2\fs20\lang2057 {\cs27 
\par int *oid_getoidbyent(struct oident *ent);
\par }\pard\plain \qj\sb100\sa100\nowidctlpar{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright \fs22\lang2057 {Takes as argument an }{\cs27\f2\fs20 oident}{ structure - in which the }{\i proto}{, }{\i oclass}{, and }{\i value}{
 fields are assumed to be set correctly - and returns a pointer to a static buffer containing the base representation of the corresponding OID. The buffer is overwritten on the next successive call to the function, so if you need to create more than one O
ID in this fashiion, you should use }{\cs27\f2\fs20 odr_oiddup()}{ or some similar measure to create a copy of the OID.
\par The }{\cs27\f2\fs20 oid_getoidbyent()}{ function can be used whenever you need to prepare a PDU containing one or more OIDs. The separation of the }{\i protocol}{ element from the 
remainer of the OID-description makes it simple to write applications that can communicate with either Z39.50 or OSI SR-based applications.
\par The function
\par }\pard\plain \s32\qj\li360\ri360\nowidctlpar\tx0\tx959\tx1918\tx2877\tx3836\tx4795\tx5754\tx6713\tx7672\tx8631{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright \f2\fs20\lang2057 {\cs27 
\par oid_value oid_getvalbyname(const char *name);
\par }\pard\plain \qj\sb100\sa100\nowidctlpar{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright \fs22\lang2057 {takes as argument a mnemonic OID name, and returns the }{\i value}{
 field of the first entry in the database that contains the given name in its }{\i desc}{ field.
\par Finally, the module provides the following utility functions, whose meaning should be obvious:
\par }\pard\plain \s32\qj\li360\ri360\nowidctlpar\tx0\tx959\tx1918\tx2877\tx3836\tx4795\tx5754\tx6713\tx7672\tx8631{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright \f2\fs20\lang2057 {\cs27 
\par void oid_oidcpy(int *t, int *s);
\par void oid_oidcat(int *t, int *s);
\par int oid_oidcmp(int *o1, int *o2);
\par int oid_oidlen(int *o);
\par }\pard\plain \qj\sb100\sa100\nowidctlpar{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright \fs22\lang2057 {\i NOTE: The }{\b\i OID}{\i 
 module has been criticized - and perhaps rightly so - for needlessly abstracting the representation of OIDs. Other toolkits use a simple string-representation of OIDs with good result
s. In practice, we have found the interface comfortable and quick to work with, and it is a simple matter (for what it's worth) to create applications compatible with both ISO SR and Z39.50. Finally, the use of the }{\cs27\i\f2\fs20 oident}{\i 
 database is by no means mandatory. You can easily create your own system for representing OIDs, as long as it is compatible with the low-level integer-array representation of the ODR module.}{
\par }\pard\plain \s19\qj\sb100\sa100\keepn\nowidctlpar{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\outlinelevel2\adjustright \b\fs36\lang2057 {{\*\bkmkstart ss4_3}{\*\bkmkstart _Toc399132426}4.3 Nibble Memory{\*\bkmkend ss4_3}{\*\bkmkend _Toc399132426}
\par }\pard\plain \qj\sb100\sa100\nowidctlpar{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright \fs22\lang2057 {Sometimes when you need to allocate and const
ruct a large, interconnected complex of structures, it can be a bit of a pain to release the associated memory again. For the structures describing the Z39.50 PDUs and related structures, it is convenient to use the memory-management system of the }{\b 
ODR}{ subsystem (see }{\field{\*\fldinst {HYPERLINK "yaz-5.html" \\l "odr-use"}{\fs20 {\*\datafield 
08d0c9ea79f9bace118c8200aa004ba90b02000000090000000303000000000000c00000000000004600000b00000079617a2d352e68746d6c00ffffadde000000000000000000000000000000000000000000000000080000006f00640072002d0075007300650000000000}}}{\fldrslt {\cs29\ul\cf2 Using ODR}}}
{). However, in some circumstances where you might otherwise benefit from using a simple nibble memory management system, it may be impractical to use }{\cs27\f2\fs20 odr_malloc()}{ and }{\b odr_reset()}{. For this purpose, 
the memory manager which also supports the }{\b ODR}{ streams is made available in the }{\b NMEM}{ module. The external interface to this module is given in the }{\cs27\f2\fs20 nmem.h}{ file.
\par The following prototypes are given:
\par }\pard\plain \s32\qj\li360\ri360\nowidctlpar\tx0\tx959\tx1918\tx2877\tx3836\tx4795\tx5754\tx6713\tx7672\tx8631{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright \f2\fs20\lang2057 {\cs27 
\par NMEM nmem_create(void);
\par void nmem_destroy(NMEM n);
\par void *nmem_malloc(NMEM n, int size);
\par void nmem_reset(NMEM n);
\par int nmem_total(NMEM n);
\par }\pard\plain \qj\sb100\sa100\nowidctlpar{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright \fs22\lang2057 {The }{\cs27\f2\fs20 nmem_create()}{ function returns a pointer to a memory control handle, which can be released again by }{\cs27\f2\fs20 
nmem_destroy()}{ when no longer needed. The function }{\cs27\f2\fs20 nmem_malloc()}{ allocates a block of memory of the requested size. A call to }{\cs27\f2\fs20 nmem_reset()}{ or }{\cs27\f2\fs20 nmem_destroy()}{
 will release all memory allocated on the handle since it was created (or since the last call to }{\cs27\f2\fs20 nmem_reset()}{. The function }{\cs27\f2\fs20 nmem_total()}{ returns the number of bytes currently allocated on the handle.
\par 
\par }\pard\plain \s19\qj\sb100\sa100\keepn\nowidctlpar{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\outlinelevel2\adjustright \b\fs36\lang2057 {{\*\bkmkstart odr}{\*\bkmkstart s5}{\*\bkmkstart _Toc399132427}{\*\bkmkend odr}5. The ODR Module{\*\bkmkend s5}
{\*\bkmkend _Toc399132427}
\par {\*\bkmkstart ss5_1}{\*\bkmkstart _Toc399132428}5.1 Introduction{\*\bkmkend ss5_1}{\*\bkmkend _Toc399132428}
\par }\pard\plain \qj\sb100\sa100\nowidctlpar{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright \fs22\lang2057 {\b ODR}{ is the BER-encoding/decoding subsystem of }{\b YAZ}{. Care as been taken to isolate }{\b ODR}{ from the rest of the package - specif
ically from the transport interface. }{\b ODR}{ may be used in any context where basic ASN.1/BER representations are used.
\par If you are only interested in writing a Z39.50 implementation based on the PDUs that are already provided with }{\b YAZ}{, you only need to concern yourself with the section on managing ODR streams (section }{\field{\*\fldinst {HYPERLINK  \\l "odr-use"}{
\fs20 {\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b0200000008000000080000006f00640072002d007500730065000000000000}}}{\fldrslt {\cs29\ul\cf2 Using ODR}}}{
). Only if you need to implement ASN.1 beyond that which has been provided, should you worry about the second half of the documentation (section }{\field{\*\fldinst {HYPERLINK  \\l "odr-prog"}{\fs20 {\*\datafield 
08d0c9ea79f9bace118c8200aa004ba90b0200000008000000090000006f00640072002d00700072006f006700000000}}}{\fldrslt {\cs29\ul\cf2 Programming with ODR}}}{). If you use one of the higher-level interfaces, you can skip this section entirely.
\par This is important, so we'll repeat it for emphasis: }{\i You do not need to read section }{\field{\*\fldinst {\i HYPERLINK  \\l "odr-prog"}{\i\fs20 {\*\datafield 
08d0c9ea79f9bace118c8200aa004ba90b0200000008000000090000006f00640072002d00700072006f006700000000}}}{\fldrslt {\cs29\i\ul\cf2 Programming with ODR}}}{\i  to implement Z39.50 with }{\b\i YAZ}{\i .}{
\par If you need a part of the protocol that isn't already in }{\b YAZ}{, you should contact the authors before going to work on it yourself: We might already be working on it. Conversely, if you implement a useful part of the protocol before us
, we'd be happy to include it in a future release.
\par }\pard\plain \s19\qj\sb100\sa100\keepn\nowidctlpar{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\outlinelevel2\adjustright \b\fs36\lang2057 {{\*\bkmkstart odr_use}{\*\bkmkstart ss5_2}{\*\bkmkstart _Toc399132429}{\*\bkmkend odr_use}5.2 Using ODR
{\*\bkmkend ss5_2}{\*\bkmkend _Toc399132429}
\par }\pard\plain \s20\qj\sb100\sa100\keepn\nowidctlpar{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\outlinelevel3\adjustright \b\fs28\lang2057 {ODR Streams
\par }\pard\plain \qj\sb100\sa100\nowidctlpar{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright \fs22\lang2057 {Conceptu
ally, the ODR stream is the source of encoded data in the decoding mode; when encoding, it is the receptacle for the encoded data. Before you can use an ODR stream it must be allocated. This is done with the function
\par }\pard\plain \s32\qj\li360\ri360\nowidctlpar\tx0\tx959\tx1918\tx2877\tx3836\tx4795\tx5754\tx6713\tx7672\tx8631{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright \f2\fs20\lang2057 {\cs27 
\par ODR odr_createmem(int direction);
\par }\pard\plain \qj\sb100\sa100\nowidctlpar{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright \fs22\lang2057 {The }{\cs27\f2\fs20 odr_createmem()}{ function takes as argument one of three manifest constants: }{\cs27\f2\fs20 ODR_ENCODE}{, }{
\cs27\f2\fs20 ODR_DECODE}{, or }{\cs27\f2\fs20 ODR_PRINT}{. An ODR stream can be in only one mode - it is not possible to change its mode once it's selected. Typically, your program will allocate at lea
st two ODR streams - one for decoding, and one for encoding.
\par When you're done with the stream, you can use
\par }\pard\plain \s32\qj\li360\ri360\nowidctlpar\tx0\tx959\tx1918\tx2877\tx3836\tx4795\tx5754\tx6713\tx7672\tx8631{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright \f2\fs20\lang2057 {\cs27 
\par void odr_destroy(ODR o);
\par }\pard\plain \qj\sb100\sa100\nowidctlpar{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright \fs22\lang2057 {to release the resources allocated for the stream.
\par }\pard\plain \s20\qj\sb100\sa100\keepn\nowidctlpar{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\outlinelevel3\adjustright \b\fs28\lang2057 {{\*\bkmkstart memory}{\*\bkmkend memory}Memory Management
\par }\pard\plain \qj\sb100\sa100\nowidctlpar{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright \fs22\lang2057 {Two forms of memory managem
ent take place in the ODR system. The first one, which has to do with allocating little bits of memory (sometimes quite large bits of memory, actually) when a protocol package is decoded, and turned into a complex of interlinked structures. This section d
eals with this system, and how you can use it for your own purposes. The next section deals with the memory management which is required when encoding data - to make sure that a large enough buffer is available to hold the fully encoded PDU.
\par The }{\b ODR}{ module 
has its own memory management system, which is used whenever memory is required. Specifically, it is used to allocate space for data when decoding incoming PDUs. You can use the memory system for your own purposes, by using the function
\par }\pard\plain \s32\qj\li360\ri360\nowidctlpar\tx0\tx959\tx1918\tx2877\tx3836\tx4795\tx5754\tx6713\tx7672\tx8631{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright \f2\fs20\lang2057 {\cs27 
\par void *odr_malloc(ODR o, int size);
\par }\pard\plain \qj\sb100\sa100\nowidctlpar{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright \fs22\lang2057 {You can't use the normal }{\cs27\f2\fs20 free}{(2) routine to free memory allocated by this function, and }{\b ODR}{
 doesn't provide a parallel function. Instead, you can call
\par }\pard\plain \s32\qj\li360\ri360\nowidctlpar\tx0\tx959\tx1918\tx2877\tx3836\tx4795\tx5754\tx6713\tx7672\tx8631{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright \f2\fs20\lang2057 {\cs27 
\par void odr_reset(ODR o, int size);
\par }\pard\plain \qj\sb100\sa100\nowidctlpar{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright \fs22\lang2057 {when you are done with the memory: Everything allocated since the last call to }{\cs27\f2\fs20 odr_reset()}{ is released. The }{\cs27\f2\fs20 
odr_reset()}{ call is also required to clear up an error condition on a stream.
\par The function
\par }\pard\plain \s32\qj\li360\ri360\nowidctlpar\tx0\tx959\tx1918\tx2877\tx3836\tx4795\tx5754\tx6713\tx7672\tx8631{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright \f2\fs20\lang2057 {\cs27 
\par int odr_total(ODR o);
\par }\pard\plain \qj\sb100\sa100\nowidctlpar{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright \fs22\lang2057 {returns the number of bytes allocated on the stream since the last call to }{\cs27\f2\fs20 odr_reset()}{.
\par The memory subsystem of }{\b ODR}{
 is fairly efficient at allocating and releasing little bits of memory. Rather than managing the individual, small bits of space, the system maintains a freelist of larger chunks of memory, which are handed out in small bits. Thi
s scheme is generally known as a }{\i nibble memory}{ system. It is very useful for maintaing short-lived constructions such as protocol PDUs.
\par If you want to retain a bit of memory beyond the next call to }{\cs27\f2\fs20 odr_reset()}{, you can use the function
\par }\pard\plain \s32\qj\li360\ri360\nowidctlpar\tx0\tx959\tx1918\tx2877\tx3836\tx4795\tx5754\tx6713\tx7672\tx8631{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright \f2\fs20\lang2057 {\cs27 
\par ODR_MEM odr_extract_mem(ODR o);
\par }\pard\plain \qj\sb100\sa100\nowidctlpar{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright \fs22\lang2057 {This function will give you control of the memory recently allocated on the ODR stream. The memory will live (past calls to }{\cs27\f2\fs20 
odr_reset()}{), until you call the function
\par }\pard\plain \s32\qj\li360\ri360\nowidctlpar\tx0\tx959\tx1918\tx2877\tx3836\tx4795\tx5754\tx6713\tx7672\tx8631{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright \f2\fs20\lang2057 {\cs27 
\par void odr_release_mem(ODR_MEM p);
\par }\pard\plain \qj\sb100\sa100\nowidctlpar{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright \fs22\lang2057 {The opaque }{\cs27\f2\fs20 ODR_MEM}{ handle has no other purpose than referencing the memory block for you until you want to release it.
\par You can use }{\cs27\f2\fs20 odr_extract_mem()}{ repeatedly between allocating data, to retain individual control of separate chunks of data.
\par }\pard\plain \s20\qj\sb100\sa100\keepn\nowidctlpar{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\outlinelevel3\adjustright \b\fs28\lang2057 {Encoding and Decoding Data
\par }\pard\plain \qj\sb100\sa100\nowidctlpar{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright \fs22\lang2057 {When encoding data, the ODR stream will write the encoded octet string in an internal buffer. To retrieve the data, use the function
\par }\pard\plain \s32\qj\li360\ri360\nowidctlpar\tx0\tx959\tx1918\tx2877\tx3836\tx4795\tx5754\tx6713\tx7672\tx8631{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright \f2\fs20\lang2057 {\cs27 
\par char *odr_getbuf(ODR o, int *len, int *size);
\par }\pard\plain \qj\sb100\sa100\nowidctlpar{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright \fs22\lang2057 {The integer pointed to by len is set to the length of the encoded data, and a pointer to that data is returned. *}{\cs27\f2\fs20 size}{
 is set to the size of the buffer (unless }{\cs27\f2\fs20 size}{ is null, signalling that you are not interested in the size). The next call to a primitive function using the same ODR stream will overwrite the data, unless a different buf
fer has been supplied using the call
\par }\pard\plain \s32\qj\li360\ri360\nowidctlpar\tx0\tx959\tx1918\tx2877\tx3836\tx4795\tx5754\tx6713\tx7672\tx8631{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright \f2\fs20\lang2057 {\cs27 
\par void odr_setbuf(ODR o, char *buf, int len, int can_grow);
\par }\pard\plain \qj\sb100\sa100\nowidctlpar{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright \fs22\lang2057 {which sets the encoding (or decoding) buffer used by }{\cs27\f2\fs20 o}{ to }{\cs27\f2\fs20 buf}{, using the length }{\cs27\f2\fs20 len}{
. Before a call to an encoding function, you can use }{\cs27\f2\fs20 odr_setbuf()}{ to provide the stream with an encoding buffer of sufficient size (length). The }{\cs27\f2\fs20 can_grow}{
 parameter tells the encoding ODR stream whether it is allowed to use }{\cs27\f2\fs20 realloc}{(2) to increase the size of the buffer when necessary. The default condition of a new encoding stream is equivalent to the results of calling
\par }\pard\plain \s32\qj\li360\ri360\nowidctlpar\tx0\tx959\tx1918\tx2877\tx3836\tx4795\tx5754\tx6713\tx7672\tx8631{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright \f2\fs20\lang2057 {\cs27 
\par odr_setbuf(stream, 0, 0, 1);
\par }\pard\plain \qj\sb100\sa100\nowidctlpar{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright \fs22\lang2057 {
In this case, the stream will allocate and reallocate memory as necessary. The stream reallocates memory by repeatedly doubling the size of the buffer - the result is that the buffer will
 typically reach its maximum, working size with only a small number of reallocation operations. The memory is freed by the stream when the latter is destroyed, unless it was assigned by the user with the }{\cs27\f2\fs20 can_grow}{
 parameter set to zero (in this case, you are expected to retain control of the memory yourself).
\par To assume full control of an encoded buffer, you must first call }{\cs27\f2\fs20 odr_getbuf()}{ to fetch the buffer and its length. Next, you should call }{\cs27\f2\fs20 odr_setbuf()}{ to provide a different buffer (or a null pointer) to 
the stream. In the simplest case, you will reuse the same buffer over and over again, and you will just need to call }{\cs27\f2\fs20 odr_getbuf()}{
 after each encoding operation to get the length and address of the buffer. Note that the stream may reallocate the buffer during an encoding operation, so it is necessary to retrieve the correct address after each encoding operation.
\par It is important to realise that the ODR stream will not release this memory when you call }{\cs27\f2\fs20 odr_reset()}{: It will merely update its internal pointers to prepare for the encoding of a new data value. When the stream is released by the }{
\cs27\f2\fs20 odr_destroy()}{ function, the memory given to it by odr_setbuf will be released }{\i only}{ if the }{\cs27\f2\fs20 can_grow}{ parameter to }{\cs27\f2\fs20 odr_setbuf()}{ was nonzero. The }{\cs27\f2\fs20 can_grow}{ parameter, in other wo
rds, is a way of signalling who is to own the buffer, you or the ODR stream. If you never call }{\cs27\f2\fs20 odr_setbuf()}{ on your encoding stream, which is typically the case, the buffer allocated by the stream will belong to the stream by default.

\par When you wish to decode data, you should first call }{\cs27\f2\fs20 odr_setbuf()}{, to tell the decoding stream where to find the encoded data, and how long the buffer is (the }{\cs27\f2\fs20 can_grow}{
 parameter is ignored by a decoding stream). After this, you can call the function corresponding to the data you wish to decode (eg, }{\cs27\f2\fs20 odr_integer()}{ odr }{\cs27\f2\fs20 z_APDU()}{).
\par Examples of encoding/decoding functions:
\par }\pard\plain \s32\qj\li360\ri360\nowidctlpar\tx0\tx959\tx1918\tx2877\tx3836\tx4795\tx5754\tx6713\tx7672\tx8631{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright \f2\fs20\lang2057 {\cs27 
\par int odr_integer(ODR o, int **p, int optional);
\par 
\par int z_APDU(ODR o, Z_APDU **p, int optional);
\par }\pard\plain \qj\sb100\sa100\nowidctlpar{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright \fs22\lang2057 {If the data is absent (or doesn't match the tag corresponding to the type), the return value will be either 0 or 1 depending on the }{
\cs27\f2\fs20 optional}{ flag. If }{\cs27\f2\fs20 optional}{ is 0 and the data is absent, an error flag will be raised in the stream, and you'll need to call }{\cs27\f2\fs20 odr_reset()}{ before you can use the stream again. If }{\cs27\f2\fs20 optional}{
 is nonzero, the pointer }{\i pointed to}{ by }{\cs27\f2\fs20 p}{ will be set to the null value, and the function will return 1.
\par If the data value is found where it's expected, the pointer }{\i pointed to}{ by the }{\cs27\f2\fs20 p}{ argume
nt will be set to point to the decoded type. The space for the type will be allocated and owned by the ODR stream, and it will live until you call }{\cs27\f2\fs20 odr_reset()}{ on the stream. You cannot use }{\cs27\f2\fs20 free}{
(2) to release the memory. You can decode several data elements (by repeated calls to }{\cs27\f2\fs20 odr_setbuf()}{ and your decoding function), and new memory will be allocated each time. When you do call }{\cs27\f2\fs20 odr_reset()}{
, everything decoded since the last call to }{\cs27\f2\fs20 odr_reset()}{ will be released.
\par The use of the double indirection can be a li
ttle confusing at first (its purpose will become clear later on, hopefully), so an example is in order. We'll encode an integer value, and immediately decode it again using a different stream. A useless, but informative operation.
\par }\pard\plain \s32\qj\li360\ri360\nowidctlpar\tx0\tx959\tx1918\tx2877\tx3836\tx4795\tx5754\tx6713\tx7672\tx8631{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright \f2\fs20\lang2057 {\cs27 
\par void do_nothing_useful(int value)
\par \{
\par     ODR encode, decode;
\par     int *valp, *resvalp;
\par     char *bufferp;
\par     int len;
\par 
\par     /* allocate streams */
\par     if (!(encode = odr_createmem(ODR_ENCODE)))
\par         return;
\par     if (!(decode = odr_createmem(ODR_DECODE)))
\par         return;
\par 
\par     valp = &value;
\par     if (odr_integer(encode, &valp, 0) == 0)
\par     \{
\par         printf("encoding went bad\\n");
\par         return;
\par     \}
\par     bufferp = odr_getbuf(encode, &len);
\par     printf("length of encoded data is %d\\n", len);
\par 
\par     /* now let's decode the thing again */
\par     odr_setbuf(decode, bufferp, len);
\par     if (odr_integer(decode, &resvalp, 0) == 0)
\par     \{
\par         printf("decoding went bad\\n");
\par         return;
\par     \}
\par     printf("the value is %d\\n", *resvalp);
\par 
\par     /* clean up */
\par     odr_destroy(encode);
\par     odr_destroy(decode);
\par \}
\par }\pard\plain \qj\sb100\sa100\nowidctlpar{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright \fs22\lang2057 {
This looks like a lot of work, offhand. In practice, the ODR streams will typically be allocated once, in the beginning of your program (or at the beginning of a new network session), and the encoding and decoding will only take 
place in a few, isolated places in your program, so the overhead is quite manageable.
\par }\pard\plain \s20\qj\sb100\sa100\keepn\nowidctlpar{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\outlinelevel3\adjustright \b\fs28\lang2057 {Diagnostics
\par }\pard\plain \qj\sb100\sa100\nowidctlpar{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright \fs22\lang2057 {The encoding/decoding functions all return 0 when an error occurs. Until you call }{\cs27\f2\fs20 odr_reset()}{
, you cannot use the stream again, and any function called will immediately return 0.
\par To provide information to the programmer or administrator, the function
\par }\pard\plain \s32\qj\li360\ri360\nowidctlpar\tx0\tx959\tx1918\tx2877\tx3836\tx4795\tx5754\tx6713\tx7672\tx8631{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright \f2\fs20\lang2057 {\cs27 
\par void odr_perror(ODR o, char *message);
\par }\pard\plain \qj\sb100\sa100\nowidctlpar{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright \fs22\lang2057 {is provided, which prints the }{\cs27\f2\fs20 message}{ argument to }{\cs27\f2\fs20 stderr}{ along with an error message from the stream.

\par You can also use the function
\par }\pard\plain \s32\qj\li360\ri360\nowidctlpar\tx0\tx959\tx1918\tx2877\tx3836\tx4795\tx5754\tx6713\tx7672\tx8631{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright \f2\fs20\lang2057 {\cs27 
\par int odr_geterror(ODR o);
\par }\pard\plain \qj\sb100\sa100\nowidctlpar{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright \fs22\lang2057 {to get the current error number from the screen. The number will be one of these constants:
\par }\pard\plain \s15\qj\sb100\sa100\nowidctlpar{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright \fs22\lang2057 {\b OMEMORY}{
\par }\pard\plain \s16\qj\li360\sb100\sa100\nowidctlpar{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright \fs22\lang2057 {Memory allocation failed.
\par }\pard\plain \s15\qj\sb100\sa100\nowidctlpar{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright \fs22\lang2057 {\b OSYSERR}{
\par }\pard\plain \s16\qj\li360\sb100\sa100\nowidctlpar{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright \fs22\lang2057 {A system- or library call has failed. The standard diagnostic variable }{\cs27\f2\fs20 errno}{ should be 
examined to determine the actual error.
\par }\pard\plain \s15\qj\sb100\sa100\nowidctlpar{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright \fs22\lang2057 {\b OSPACE}{
\par }\pard\plain \s16\qj\li360\sb100\sa100\nowidctlpar{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright \fs22\lang2057 {
No more space for encoding. This will only occur when the user has explicitly provided a buffer for an encoding stream without allowing the system to allocate more space.
\par }\pard\plain \s15\qj\sb100\sa100\nowidctlpar{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright \fs22\lang2057 {\b OREQUIRED}{
\par }\pard\plain \s16\qj\li360\sb100\sa100\nowidctlpar{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright \fs22\lang2057 {This is a common protocol error; A required data element was missing during encoding or decoding.
\par }\pard\plain \s15\qj\sb100\sa100\nowidctlpar{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright \fs22\lang2057 {\b OUNEXPECTED}{
\par }\pard\plain \s16\qj\li360\sb100\sa100\nowidctlpar{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright \fs22\lang2057 {An unexpected data element was found during decoding.
\par }\pard\plain \s15\qj\sb100\sa100\nowidctlpar{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright \fs22\lang2057 {\b OOTHER}{
\par }\pard\plain \s16\qj\li360\sb100\sa100\nowidctlpar{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright \fs22\lang2057 {Other error. This is typically an indication of misuse of the }{\b ODR}{
 system by the programmer, and also that the diagnostic system isn't as good as it should be, yet.
\par }\pard\plain \qj\sb100\sa100\nowidctlpar{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright \fs22\lang2057 {The character string array
\par }\pard\plain \s32\qj\li360\ri360\nowidctlpar\tx0\tx959\tx1918\tx2877\tx3836\tx4795\tx5754\tx6713\tx7672\tx8631{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright \f2\fs20\lang2057 {\cs27 
\par char *odr_errlist[]
\par }\pard\plain \qj\sb100\sa100\nowidctlpar{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright \fs22\lang2057 {can be indexed by the error code to obtain a human-readable representation of the problem.
\par }\pard\plain \s20\qj\sb100\sa100\keepn\nowidctlpar{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\outlinelevel3\adjustright \b\fs28\lang2057 {Summary and Synopsis
\par }\pard\plain \s32\qj\li360\ri360\nowidctlpar\tx0\tx959\tx1918\tx2877\tx3836\tx4795\tx5754\tx6713\tx7672\tx8631{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright \f2\fs20\lang2057 {\cs27 
\par #include <odr.h>
\par 
\par ODR odr_createmem(int direction);
\par 
\par void odr_destroy(ODR o);
\par 
\par void odr_reset(ODR o);
\par 
\par char *odr_getbuf(ODR o, int *len);
\par 
\par void odr_setbuf(ODR o, char *buf, int len);
\par 
\par void *odr_malloc(ODR o, int size);
\par 
\par ODR_MEM odr_extract_mem(ODR o);
\par 
\par void odr_release_mem(ODR_MEM r);
\par 
\par int odr_geterror(ODR o);
\par 
\par void odr_perror(char *message);
\par 
\par extern char *odr_errlist[];
\par }\pard\plain \s19\qj\sb100\sa100\keepn\nowidctlpar{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\outlinelevel2\adjustright \b\fs36\lang2057 {{\*\bkmkstart odr_prog}{\*\bkmkstart ss5_3}{\*\bkmkstart _Toc399132430}{\*\bkmkend odr_prog}5.3 Programming with ODR
{\*\bkmkend ss5_3}{\*\bkmkend _Toc399132430}
\par }\pard\plain \qj\sb100\sa100\nowidctlpar{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright \fs22\lang2057 {The API of }{\b ODR}{ is desig
ned to reflect the structure of ASN.1, rather than BER itself. Future releases may be able to represent data in other external forms.
\par The interface is based loosely on that of the Sun Microsystems XDR routines. Specifically, each function which corresponds
 to an ASN.1 primitive type has a dual function. Depending on the settings of the ODR stream which is supplied as a parameter, the function may be used either to encode or decode data. The functions that can be built using these primitive functions, to re
p
resent more complex datatypes, share this quality. The result is that you only have to enter the definition for a type once - and you have the functionality of encoding, decoding (and pretty-printing) all in one unit. The resulting C source code is quite 
compact, and is a pretty straightforward representation of the source ASN.1 specification. Although no ASN.1 compiler is supplied with }{\b ODR}{
 at this time, it shouldn't be too difficult to write one, or perhaps even to adapt an existing compiler to output }{\b ODR}{ routines (not surprisingly, writing encoders/decoders using }{\b ODR}{ turns out to be boring work).
\par In many cases, the model of the XDR functions works quite well in this role. In others, it is less elegant. Most of the hassle comes from the optional SEQUENCE memebers which don't exist in XDR.
\par }\pard\plain \s20\qj\sb100\sa100\keepn\nowidctlpar{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\outlinelevel3\adjustright \b\fs28\lang2057 {The Primitive ASN.1 Types
\par }\pard\plain \qj\sb100\sa100\nowidctlpar{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright \fs22\lang2057 {ASN.1 defines a number of primitive types (many of which correspond roughly to primitive types in structured programming languages, such as C).

\par }\pard\plain \s20\qj\sb100\sa100\keepn\nowidctlpar{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\outlinelevel3\adjustright \b\fs28\lang2057 {INTEGER
\par }\pard\plain \qj\sb100\sa100\nowidctlpar{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright \fs22\lang2057 {The }{\b ODR}{ function for encoding or decoding (or printing) the ASN.1 INTEGER type looks like this:
\par }\pard\plain \s32\qj\li360\ri360\nowidctlpar\tx0\tx959\tx1918\tx2877\tx3836\tx4795\tx5754\tx6713\tx7672\tx8631{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright \f2\fs20\lang2057 {\cs27 
\par int odr_integer(ODR o, int **p, int optional);
\par }\pard\plain \qj\sb100\sa100\nowidctlpar{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright \fs22\lang2057 {(we don't allow values that can't be contained in a C integer.)
\par This form is typical of the primitive }{\b ODR}{ functions. They are named after the type of data that they encode or decode. They take an ODR stream, an indirect reference to the type in question, and an }{\cs27\f2\fs20 optional}{
 flag (corresponding to the OPTIONAL keyword of ASN.1) as parameters. They all return an integer value of either one or zero. When you use the 
primitive functions to construct encoders for complex types of your own, you should follow this model as well. This ensures that your new types can be reused as elements in yet more complex types.
\par The }{\cs27\f2\fs20 o}{ parameter should obviously refer to a properly initialized ODR stream of the right type (encoding/decoding/printing) for the operation that you wish to perform.
\par When encoding or printing, the function first looks at *}{\cs27\f2\fs20 p}{. If *}{\cs27\f2\fs20 p}{ (the pointer pointed to by }{\cs27\f2\fs20 p}{) is a null pointer, this is taken to mean that the data element is absent. If the }{\cs27\f2\fs20 optional}
{ parameter is nonzero, the function will return one (signifying success) without any further processing. If the }{\cs27\f2\fs20 optional}{ is zero, an internal error flag is set in the ODR stream, and the function will return 0. No furthe
r operations can be carried out on the stream without a call to the function }{\cs27\f2\fs20 odr_reset()}{.
\par If *}{\cs27\f2\fs20 p}{ is not a null pointer, it is expected to point to an instance of the data type. The data will be subjected to the encoding rules, and the result will be placed in the buffer held by the ODR stream.
\par The other ASN.1 primitives have similar functions that operate in similar manners:
\par }\pard\plain \s20\qj\sb100\sa100\keepn\nowidctlpar{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\outlinelevel3\adjustright \b\fs28\lang2057 {BOOLEAN
\par }\pard\plain \s32\qj\li360\ri360\nowidctlpar\tx0\tx959\tx1918\tx2877\tx3836\tx4795\tx5754\tx6713\tx7672\tx8631{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright \f2\fs20\lang2057 {\cs27 
\par int odr_bool(ODR o, bool_t **p, int optional);
\par }\pard\plain \s20\qj\sb100\sa100\keepn\nowidctlpar{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\outlinelevel3\adjustright \b\fs28\lang2057 {REAL
\par }\pard\plain \qj\sb100\sa100\nowidctlpar{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright \fs22\lang2057 {Not defined.
\par }\pard\plain \s20\qj\sb100\sa100\keepn\nowidctlpar{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\outlinelevel3\adjustright \b\fs28\lang2057 {NULL
\par }\pard\plain \s32\qj\li360\ri360\nowidctlpar\tx0\tx959\tx1918\tx2877\tx3836\tx4795\tx5754\tx6713\tx7672\tx8631{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright \f2\fs20\lang2057 {\cs27 
\par int odr_null(ODR o, bool_t **p, int optional);
\par }\pard\plain \qj\sb100\sa100\nowidctlpar{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright \fs22\lang2057 {In this case, the value of **p is not important. If *p is different from the null pointer, the null value is present, otherwise it's absent.

\par }\pard\plain \s20\qj\sb100\sa100\keepn\nowidctlpar{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\outlinelevel3\adjustright \b\fs28\lang2057 {OCTET STRING
\par }\pard\plain \s32\qj\li360\ri360\nowidctlpar\tx0\tx959\tx1918\tx2877\tx3836\tx4795\tx5754\tx6713\tx7672\tx8631{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright \f2\fs20\lang2057 {\cs27 
\par typedef struct odr_oct
\par \{
\par     unsigned char *buf;
\par     int len;
\par     int size;
\par \} Odr_oct;
\par 
\par int odr_octetstring(ODR o, Odr_oct **p, int optional);
\par }\pard\plain \qj\sb100\sa100\nowidctlpar{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright \fs22\lang2057 {The }{\cs27\f2\fs20 buf}{ field should point to the character array that holds the octetstring. The }{\cs27\f2\fs20 len}{
 field holds the actual length, while the }{\cs27\f2\fs20 size}{ field gives the size of the allocated array (not of interest to you, in most cases). The character array need not be null terminated.
\par To make things a little easier, an alternative is given for string types that are not expected to contain embedded NULL characters (eg. VisibleString):
\par }\pard\plain \s32\qj\li360\ri360\nowidctlpar\tx0\tx959\tx1918\tx2877\tx3836\tx4795\tx5754\tx6713\tx7672\tx8631{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright \f2\fs20\lang2057 {\cs27 
\par int odr_cstring(ODR o, char **p, int optional);
\par }\pard\plain \qj\sb100\sa100\nowidctlpar{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright \fs22\lang2057 {Which encoded or decodes between OCTETSTRING representations and null-terminates C strings.
\par Functions are provided for the derived string types, eg:
\par }\pard\plain \s32\qj\li360\ri360\nowidctlpar\tx0\tx959\tx1918\tx2877\tx3836\tx4795\tx5754\tx6713\tx7672\tx8631{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright \f2\fs20\lang2057 {\cs27 
\par int odr_visiblestring(ODR o, char **p, int optional);
\par }\pard\plain \s20\qj\sb100\sa100\keepn\nowidctlpar{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\outlinelevel3\adjustright \b\fs28\lang2057 {BIT STRING
\par }\pard\plain \s32\qj\li360\ri360\nowidctlpar\tx0\tx959\tx1918\tx2877\tx3836\tx4795\tx5754\tx6713\tx7672\tx8631{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright \f2\fs20\lang2057 {\cs27 
\par int odr_bitstring(ODR o, Odr_bitmask **p, int optional);
\par }\pard\plain \qj\sb100\sa100\nowidctlpar{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright \fs22\lang2057 {The opaque type }{\cs27\f2\fs20 Odr_bitmask}{
 is only suitable for holding relatively brief bit strings, eg. for options fields, etc. The constant }{\cs27\f2\fs20 ODR_BITMASK_SIZE}{ multiplied by 8 gives the maximum possible number of bits.
\par A set of macros are provided for manipulating the }{\cs27\f2\fs20 Odr_bitmask}{ type:
\par }\pard\plain \s32\qj\li360\ri360\nowidctlpar\tx0\tx959\tx1918\tx2877\tx3836\tx4795\tx5754\tx6713\tx7672\tx8631{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright \f2\fs20\lang2057 {\cs27 
\par void ODR_MASK_ZERO(Odr_bitmask *b);
\par 
\par void ODR_MASK_SET(Odr_bitmask *b, int bitno);
\par 
\par void ODR_MASK_CLEAR(Odr_bitmask *b, int bitno);
\par 
\par int ODR_MASK_GET(Odr_bitmask *b, int bitno);
\par }\pard\plain \qj\sb100\sa100\nowidctlpar{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright \fs22\lang2057 {The functions are modelled after the manipulation functions that accompany the }{\cs27\f2\fs20 fd_set}{ type used by the }{\cs27\f2\fs20 select
}{(2) call. }{\cs27\f2\fs20 ODR_MASK_ZERO}{ should always be called first on a new bitmask, to initialize the bits to zero.
\par }\pard\plain \s20\qj\sb100\sa100\keepn\nowidctlpar{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\outlinelevel3\adjustright \b\fs28\lang2057 {OBJECT IDENTIFIER
\par }\pard\plain \s32\qj\li360\ri360\nowidctlpar\tx0\tx959\tx1918\tx2877\tx3836\tx4795\tx5754\tx6713\tx7672\tx8631{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright \f2\fs20\lang2057 {\cs27 
\par int odr_oid(ODR o, Odr_oid **p, int optional);
\par }\pard\plain \qj\sb100\sa100\nowidctlpar{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright \fs22\lang2057 {The C OID represenation is simply an array of integers, terminated by the value -1 (the }{\cs27\f2\fs20 Odr_oid}{ type is synonymous with the }
{\cs27\f2\fs20 int}{ type). We suggest that you use the OID database module (see section }{\field{\*\fldinst {HYPERLINK "yaz-3.html" \\l "oid"}{\fs20 {\*\datafield 
08d0c9ea79f9bace118c8200aa004ba90b02000000090000000303000000000000c00000000000004600000b00000079617a2d332e68746d6c00ffffadde000000000000000000000000000000000000000000000000040000006f006900640000000000}}}{\fldrslt {\cs29\ul\cf2 Object Identifiers}}}{
) to handle object identifiers in your application.
\par }\pard\plain \s20\qj\sb100\sa100\keepn\nowidctlpar{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\outlinelevel3\adjustright \b\fs28\lang2057 {{\*\bkmkstart tag_prim}{\*\bkmkend tag_prim}Tagging Primitive Types
\par }\pard\plain \qj\sb100\sa100\nowidctlpar{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright \fs22\lang2057 {The simplest way of tagging a type is to use the }{\cs27\f2\fs20 odr_implicit()}{ or }{\cs27\f2\fs20 odr_explicit()}{ macros:
\par }\pard\plain \s32\qj\li360\ri360\nowidctlpar\tx0\tx959\tx1918\tx2877\tx3836\tx4795\tx5754\tx6713\tx7672\tx8631{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright \f2\fs20\lang2057 {\cs27 
\par int odr_implicit(ODR o, Odr_fun fun, int class, int tag, int
\par                     optional);
\par 
\par int odr_explicit(ODR o, Odr_fun fun, int class, int tag,
\par                     int optional);
\par }\pard\plain \qj\sb100\sa100\nowidctlpar{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright \fs22\lang2057 {To create a type derived from the integer type by implicit tagging, you might write:
\par }\pard\plain \s32\qj\li360\ri360\nowidctlpar\tx0\tx959\tx1918\tx2877\tx3836\tx4795\tx5754\tx6713\tx7672\tx8631{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright \f2\fs20\lang2057 {\cs27 
\par MyInt ::= [210] IMPLICIT INTEGER
\par }\pard\plain \qj\sb100\sa100\nowidctlpar{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright \fs22\lang2057 {In the }{\b ODR}{ system, this would be written like:
\par }\pard\plain \s32\qj\li360\ri360\nowidctlpar\tx0\tx959\tx1918\tx2877\tx3836\tx4795\tx5754\tx6713\tx7672\tx8631{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright \f2\fs20\lang2057 {\cs27 
\par int myInt(ODR o, int **p, int optional)
\par \{
\par     return odr_implicit(o, odr_integer, p, ODR_CONTEXT, 210, optional);
\par \}
\par }\pard\plain \qj\sb100\sa100\nowidctlpar{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright \fs22\lang2057 {The function }{\cs27\f2\fs20 myInt()}{ can then be used like any of the primitive functions provided by ODR. Note that the behavior of }{
\cs27\f2\fs20 odr_explicit()}{ and }{\cs27\f2\fs20 odr_implicit()}{
 macros act exactly the same as the functions they are applied to - they respond to error conditions, etc, in the same manner - they simply have three extra parameters. The class parameter may take one of the values: }{\cs27\f2\fs20 ODR_CONTEXT}{, }{
\cs27\f2\fs20 ODR_PRIVATE}{, }{\cs27\f2\fs20 ODR_UNIVERSAL}{, or }{\cs27\f2\fs20 ODR_APPLICATION}{.
\par }\pard\plain \s20\qj\sb100\sa100\keepn\nowidctlpar{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\outlinelevel3\adjustright \b\fs28\lang2057 {Constructed Types
\par }\pard\plain \qj\sb100\sa100\nowidctlpar{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright \fs22\lang2057 {Constructed types are created by combining primitive types. The }{\b ODR}{
 system only implements the SEQUENCE and SEQUENCE OF constructions (although adding the rest of the container types should be simple enough, if the need arises).
\par For implementing SEQUENCEs, the functions
\par }\pard\plain \s32\qj\li360\ri360\nowidctlpar\tx0\tx959\tx1918\tx2877\tx3836\tx4795\tx5754\tx6713\tx7672\tx8631{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright \f2\fs20\lang2057 {\cs27 
\par int odr_sequence_begin(ODR o, void *p, int size);
\par int odr_sequence_end(ODR o);
\par }\pard\plain \qj\sb100\sa100\nowidctlpar{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright \fs22\lang2057 {are provided.
\par The }{\cs27\f2\fs20 odr_sequence_begin()}{ function should be called in the beginning of a function that implements a SEQUENCE type. Its parameters are the }{\b ODR}{ stream, a pointer (to a pointer to the type you're implementing), and the }{
\cs27\f2\fs20 size}{ of the type (typically a C structure). On encoding, it returns 1 if *}{\cs27\f2\fs20 p}{ is a null pointer. The }{\cs27\f2\fs20 size}{ parameter is ignored. On decoding, it returns 1 if the type is found in the data stream. }{
\cs27\f2\fs20 size}{ bytes of memory are allocated, and *}{\cs27\f2\fs20 p}{ is set to point to this space. }{\cs27\f2\fs20 odr_sequence_end()}{ is called at the end of the complex function. Assume that a type is defined like this:
\par }\pard\plain \s32\qj\li360\ri360\nowidctlpar\tx0\tx959\tx1918\tx2877\tx3836\tx4795\tx5754\tx6713\tx7672\tx8631{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright \f2\fs20\lang2057 {\cs27 
\par MySequence ::= SEQUENCE \{
\par     intval INTEGER,
\par     boolval BOOLEAN OPTIONAL \}
\par }\pard\plain \qj\sb100\sa100\nowidctlpar{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright \fs22\lang2057 {The corresponding ODR encoder/decoder function and the associated data structures could be written like this:
\par }\pard\plain \s32\qj\li360\ri360\nowidctlpar\tx0\tx959\tx1918\tx2877\tx3836\tx4795\tx5754\tx6713\tx7672\tx8631{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright \f2\fs20\lang2057 {\cs27 
\par typedef struct MySequence
\par \{
\par     int *intval;
\par     bool_t *boolval;
\par \} MySequence;
\par 
\par int mySequence(ODR o, MySequence **p, int optional)
\par \{
\par     if (odr_sequence_begin(o, p, sizeof(**p)) == 0)
\par         return optional && odr_ok(o);
\par     return
\par         odr_integer(o, &(*p)->intval, 0) &&
\par         odr_bool(o, &(*p)->boolval, 1) &&
\par         odr_sequence_end(o);
\par \}
\par }\pard\plain \qj\sb100\sa100\nowidctlpar{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright \fs22\lang2057 {Note the 1 in the call to }{\cs27\f2\fs20 odr_bool()}{
, to mark that the sequence member is optional. If either of the member types had been tagged, the macros }{\cs27\f2\fs20 odr_implicit()}{ or }{\cs27\f2\fs20 odr_explicit()}{
 could have been used. The new function can be used exactly like the standard functions provided with }{\b ODR}{. It will encode, decode or pretty-print a data value of the }{\cs27\f2\fs20 MySequence}{
 type. We like to name types with an initial capital, as done in ASN.1 definitio
ns, and to name the corresponding function with the first character of the name in lower case. You could, of course, name your structures, types, and functions any way you please - as long as you're consistent, and your code is easily readable. }{
\cs27\f2\fs20 odr_ok}{ is just that - a predicate that returns the state of the stream. It is used to ensure that the behaviour of the new type is compatible with the interface of the primitive types.
\par }\pard\plain \s20\qj\sb100\sa100\keepn\nowidctlpar{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\outlinelevel3\adjustright \b\fs28\lang2057 {Tagging Constructed Types
\par }\pard\plain \qj\sb100\sa100\nowidctlpar{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright \fs22\lang2057 {\i NOTE: See section }{\field{\*\fldinst {\i HYPERLINK  \\l "tag-prim"}{\i\fs20 {\*\datafield 
08d0c9ea79f9bace118c8200aa004ba90b0200000008000000090000007400610067002d007000720069006d00000000}}}{\fldrslt {\cs29\i\ul\cf2 Tagging Primitive types}}}{\i  for information on how to tag the primitive types, as well as types that are already defined.}{

\par }\pard\plain \s20\qj\sb100\sa100\keepn\nowidctlpar{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\outlinelevel3\adjustright \b\fs28\lang2057 {Implicit Tagging
\par }\pard\plain \qj\sb100\sa100\nowidctlpar{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright \fs22\lang2057 {Assume the type above had been defined as
\par }\pard\plain \s32\qj\li360\ri360\nowidctlpar\tx0\tx959\tx1918\tx2877\tx3836\tx4795\tx5754\tx6713\tx7672\tx8631{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright \f2\fs20\lang2057 {\cs27 
\par MySequence ::= [10] IMPLICIT SEQUENCE \{
\par     intval INTEGER,
\par     boolval BOOLEAN OPTIONAL \}
\par }\pard\plain \qj\sb100\sa100\nowidctlpar{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright \fs22\lang2057 {You would implement this in }{\b ODR}{ by calling the function
\par }\pard\plain \s32\qj\li360\ri360\nowidctlpar\tx0\tx959\tx1918\tx2877\tx3836\tx4795\tx5754\tx6713\tx7672\tx8631{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright \f2\fs20\lang2057 {\cs27 
\par int odr_implicit_settag(ODR o, int class, int tag);
\par }\pard\plain \qj\sb100\sa100\nowidctlpar{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright \fs22\lang2057 {which overrides the tag of the type immediately following it. The macro }{\cs27\f2\fs20 odr_implicit()}{ works by calling }{\cs27\f2\fs20 
odr_implicit_settag()}{ immediately before calling the function pointer argument. Your type function could look like this:
\par }\pard\plain \s32\qj\li360\ri360\nowidctlpar\tx0\tx959\tx1918\tx2877\tx3836\tx4795\tx5754\tx6713\tx7672\tx8631{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright \f2\fs20\lang2057 {\cs27 
\par int mySequence(ODR o, MySequence **p, int optional)
\par \{
\par     if (odr_implicit_settag(o, ODR_CONTEXT, 10) == 0 ||
\par         odr_sequence_begin(o, p, sizeof(**p)) == 0)
\par         return optional && odr_ok(o);
\par     return
\par         odr_integer(o, &(*p)->intval, 0) &&
\par         odr_bool(o, &(*p)->boolval, 1) &&
\par         odr_sequence_end(o);
\par \}
\par }\pard\plain \qj\sb100\sa100\nowidctlpar{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright \fs22\lang2057 {The definition of the structure }{\cs27\f2\fs20 MySequence}{ would be the same.
\par }\pard\plain \s20\qj\sb100\sa100\keepn\nowidctlpar{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\outlinelevel3\adjustright \b\fs28\lang2057 {Explicit Tagging
\par }\pard\plain \qj\sb100\sa100\nowidctlpar{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright \fs22\lang2057 {Explicit tagging of constructed types is a little more complicated, since you are in effect adding a level of construction to the data.
\par Assume the definition:
\par }\pard\plain \s32\qj\li360\ri360\nowidctlpar\tx0\tx959\tx1918\tx2877\tx3836\tx4795\tx5754\tx6713\tx7672\tx8631{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright \f2\fs20\lang2057 {\cs27 
\par MySequence ::= [10] IMPLICIT SEQUENCE \{
\par     intval INTEGER,
\par     boolval BOOLEAN OPTIONAL \}
\par }\pard\plain \qj\sb100\sa100\nowidctlpar{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright \fs22\lang2057 {Since the new type has an extra level of construction, two new functions are needed to encapsulate the base type:
\par }\pard\plain \s32\qj\li360\ri360\nowidctlpar\tx0\tx959\tx1918\tx2877\tx3836\tx4795\tx5754\tx6713\tx7672\tx8631{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright \f2\fs20\lang2057 {\cs27 
\par int odr_constructed_begin(ODR o, void *p, int class, int tag);
\par 
\par int odr_constructed_end(ODR o);
\par }\pard\plain \qj\sb100\sa100\nowidctlpar{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright \fs22\lang2057 {Assume that the IMPLICIT in the type definiti
on above were replaced with EXPLICIT (or that the IMPLICIT keyword were simply deleted, which would be equivalent). The structure definition would look the same, but the function would look like this:
\par }\pard\plain \s32\qj\li360\ri360\nowidctlpar\tx0\tx959\tx1918\tx2877\tx3836\tx4795\tx5754\tx6713\tx7672\tx8631{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright \f2\fs20\lang2057 {\cs27 
\par int mySequence(ODR o, MySequence **p, int optional)
\par \{
\par     if (odr_constructed_begin(o, p, ODR_CONTEXT, 10) == 0)
\par         return optional && odr_ok(o);
\par     if (o->direction == ODR_DECODE)
\par         *p = odr_malloc(o, sizeof(**p));
\par     if (odr_sequence_begin(o, p, sizeof(**p)) == 0)
\par     \{
\par         *p = 0; /* this is almost certainly a protocol error */
\par         return 0;
\par     \}
\par     return
\par         odr_integer(o, &(*p)->intval, 0) &&
\par         odr_bool(o, &(*p)->boolval, 1) &&
\par         odr_sequence_end(o) &&
\par         odr_constructed_end(o);
\par \}
\par }\pard\plain \qj\sb100\sa100\nowidctlpar{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright \fs22\lang2057 {
Notice that the interface here gets kind of nasty. The reason is simple: Explicitly tagged, constructed types are fairly rare in the protocols that we care about, so the aesthetic annoyance (not to mention the dangers of a cluttered interface) is less tha
n the time that would be required to develop a better interface. Nevertheless, it is far from satisfying, and it's a point that will be worked on in the future. One option for you would be to simply apply the }{\cs27\f2\fs20 odr_explicit()}{
 macro to the first function, and not have to worry about }{\cs27\f2\fs20 odr_constructed_*}{ yourself. Incidentally, as you might have guessed, the }{\cs27\f2\fs20 odr_sequence_}{ functions are themselves implemented using the }{\cs27\f2\fs20 
odr_constructed_}{ functions.
\par }\pard\plain \s20\qj\sb100\sa100\keepn\nowidctlpar{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\outlinelevel3\adjustright \b\fs28\lang2057 {SEQUENCE OF
\par }\pard\plain \qj\sb100\sa100\nowidctlpar{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright \fs22\lang2057 {To handle sequences (arrays) of a apecific type, the function
\par }\pard\plain \s32\qj\li360\ri360\nowidctlpar\tx0\tx959\tx1918\tx2877\tx3836\tx4795\tx5754\tx6713\tx7672\tx8631{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright \f2\fs20\lang2057 {\cs27 
\par int odr_sequence_of(ODR o, int (*fun)(ODR o, void *p, int optional),
\par                         void *p, int *num);
\par }\pard\plain \qj\sb100\sa100\nowidctlpar{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright \fs22\lang2057 {The }{\cs27\f2\fs20 fun}{ parameter is a pointer to the decoder/encoder function of the type. }{\cs27\f2\fs20 p}{
 is a pointer to an array of pointers to your type. }{\cs27\f2\fs20 num}{ is the number of elements in the array.
\par Assume a type
\par }\pard\plain \s32\qj\li360\ri360\nowidctlpar\tx0\tx959\tx1918\tx2877\tx3836\tx4795\tx5754\tx6713\tx7672\tx8631{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright \f2\fs20\lang2057 {\cs27 
\par MyArray ::= SEQUENCE OF INTEGER
\par }\pard\plain \qj\sb100\sa100\nowidctlpar{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright \fs22\lang2057 {The C representation might be
\par }\pard\plain \s32\qj\li360\ri360\nowidctlpar\tx0\tx959\tx1918\tx2877\tx3836\tx4795\tx5754\tx6713\tx7672\tx8631{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright \f2\fs20\lang2057 {\cs27 
\par typedef struct MyArray
\par \{
\par     int num_elements;
\par     int **elements;
\par \} MyArray;
\par }\pard\plain \qj\sb100\sa100\nowidctlpar{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright \fs22\lang2057 {And the function might look like
\par }\pard\plain \s32\qj\li360\ri360\nowidctlpar\tx0\tx959\tx1918\tx2877\tx3836\tx4795\tx5754\tx6713\tx7672\tx8631{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright \f2\fs20\lang2057 {\cs27 
\par int myArray(ODR o, MyArray **p, int optional)
\par \{
\par     if (o->direction == ODR_DECODE)
\par         *p = odr_malloc(o, sizeof(**p));
\par     if (odr_sequence_of(o, odr_integer, &(*p)->elements,
\par         &(*p)->num_elements))
\par         return 1;
\par     *p = 0;
\par     return optional && odr_ok(o);
\par \}
\par }\pard\plain \s20\qj\sb100\sa100\keepn\nowidctlpar{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\outlinelevel3\adjustright \b\fs28\lang2057 {CHOICE Types
\par }\pard\plain \qj\sb100\sa100\nowidctlpar{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright \fs22\lang2057 {The choice type is used fairly often in some ASN.1 definitions, so some work has gone into streamlining its interface.
\par CHOICE types are handled by the function:
\par }\pard\plain \s32\qj\li360\ri360\nowidctlpar\tx0\tx959\tx1918\tx2877\tx3836\tx4795\tx5754\tx6713\tx7672\tx8631{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright \f2\fs20\lang2057 {\cs27 
\par int odr_choice(ODR o, Odr_arm arm[], void *p, int *whichp);
\par }\pard\plain \qj\sb100\sa100\nowidctlpar{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright \fs22\lang2057 {The }{\cs27\f2\fs20 arm}{ array is used
 to describe each of the possible types that the CHOICE type may assume. Internally in your application, the CHOICE type is represented as a discriminated union. That is, a C union accompanied by an integer (or enum) identifying the active 'arm' of the un
ion. }{\cs27\f2\fs20 whichp}{ is a pointer to the union discriminator. When encoding, it is examined to determine the current type. When decoding, it is set to reference the type that was found in the input stream.
\par The Odr_arm type is defined thus:
\par }\pard\plain \s32\qj\li360\ri360\nowidctlpar\tx0\tx959\tx1918\tx2877\tx3836\tx4795\tx5754\tx6713\tx7672\tx8631{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright \f2\fs20\lang2057 {\cs27 
\par typedef struct odr_arm
\par \{
\par     int tagmode;
\par     int class;
\par     int tag;
\par     int which;
\par     Odr_fun fun;
\par \} Odr_arm;
\par }\pard\plain \qj\sb100\sa100\nowidctlpar{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright \fs22\lang2057 {The interpretation of the fields are:
\par }\pard\plain \s15\qj\sb100\sa100\nowidctlpar{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright \fs22\lang2057 {\b tagmode}{
\par }\pard\plain \s16\qj\li360\sb100\sa100\nowidctlpar{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright \fs22\lang2057 {Either }{\cs27\f2\fs20 ODR_IMPLICIT}{, }{\cs27\f2\fs20 ODR_EXPLICIT}{, or }{\cs27\f2\fs20 ODR_NONE}{ (-1) to mark no tagging.
\par }\pard\plain \s15\qj\sb100\sa100\nowidctlpar{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright \fs22\lang2057 {\b class, tag}{
\par }\pard\plain \s16\qj\li360\sb100\sa100\nowidctlpar{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright \fs22\lang2057 {The class and tag of the type (-1 if no tagging is used).
\par }\pard\plain \s15\qj\sb100\sa100\nowidctlpar{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright \fs22\lang2057 {\b which}{
\par }\pard\plain \s16\qj\li360\sb100\sa100\nowidctlpar{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright \fs22\lang2057 {The value of the discriminator that corresponds to this CHOICE element. Typically, it will be a #defined constant, or an enum member.

\par }\pard\plain \s15\qj\sb100\sa100\nowidctlpar{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright \fs22\lang2057 {\b fun}{
\par }\pard\plain \s16\qj\li360\sb100\sa100\nowidctlpar{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright \fs22\lang2057 {A pointer to a function that implements the type of the CHOICE member. It may be either a standard }{\b ODR}{
 type or a type defined by yourself.
\par }\pard\plain \qj\sb100\sa100\nowidctlpar{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright \fs22\lang2057 {A handy way to prepare the array for use by the }{\cs27\f2\fs20 odr_choice()}{
 function is to define it as a static, initialized array in the beginning of your decoding/encoding function. Assume the type definition:
\par }\pard\plain \s32\qj\li360\ri360\nowidctlpar\tx0\tx959\tx1918\tx2877\tx3836\tx4795\tx5754\tx6713\tx7672\tx8631{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright \f2\fs20\lang2057 {\cs27 
\par MyChoice ::= CHOICE \{
\par     untagged INTEGER,
\par     tagged   [99] IMPLICIT INTEGER,
\par     other    BOOLEAN
\par \}
\par }\pard\plain \qj\sb100\sa100\nowidctlpar{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright \fs22\lang2057 {Your C type might look like
\par }\pard\plain \s32\qj\li360\ri360\nowidctlpar\tx0\tx959\tx1918\tx2877\tx3836\tx4795\tx5754\tx6713\tx7672\tx8631{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright \f2\fs20\lang2057 {\cs27 
\par typedef struct MyChoice
\par \{
\par     enum
\par     \{
\par         MyChoice_untagged,
\par         MyChoice_tagged,
\par         MyChoice_other
\par     \} which;
\par     union
\par     \{
\par         int *untagged;
\par         int *tagged;
\par         bool_t *other;
\par     \} u;
\par \};
\par }\pard\plain \qj\sb100\sa100\nowidctlpar{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright \fs22\lang2057 {And your function could look like this:
\par }\pard\plain \s32\qj\li360\ri360\nowidctlpar\tx0\tx959\tx1918\tx2877\tx3836\tx4795\tx5754\tx6713\tx7672\tx8631{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright \f2\fs20\lang2057 {\cs27 
\par int myChoice(ODR o, MyChoice **p, int optional)
\par \{
\par     static Odr_arm arm[] =
\par     \{
\par         \{-1, -1, -1, MyChoice_untagged, odr_integer\},
\par         \{ODR_IMPLICIT, ODR_CONTEXT, 99, MyChoice_tagged, odr_integer\},
\par         \{-1, -1, -1, MyChoice_other, odr_boolean\},
\par         \{-1, -1, -1, -1, 0\}
\par     \};
\par 
\par     if (o->direction == ODR_DECODE)
\par         *p = odr_malloc(o, sizeof(**p);
\par     else if (!*p)
\par         return optional && odr_ok(o);
\par 
\par     if (odr_choice(o, arm, &(*p)->u, &(*p)->which))
\par         return 1;
\par     *p = 0;
\par     return optional && odr_ok(o);
\par \}
\par }\pard\plain \qj\sb100\sa100\nowidctlpar{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright \fs22\lang2057 {In some cases (say, a non-optional choice which is a membe
r of a sequence), you can "embed" the union and its discriminator in the structure belonging to the enclosing type, and you won't need to fiddle with memory allocation to create a separate structure to wrap the discriminator and union.
\par The corresponding function is somewhat nicer in the Sun XDR interface. Most of the complexity of this interface comes from the possibility of declaring sequence elements (including CHOICEs) optional.
\par The ASN.1 specifictions naturally requires that each member of a CHOICE have
 a distinct tag, so they can be told apart on decoding. Sometimes it can be useful to define a CHOICE that has multiple types that share the same tag. You'll need some other mechanism, perhaps keyed to the context of the CHOICE type. In effect, we would l
i
ke to introduce a level of context-sensitiveness to our ASN.1 specification. When encoding an internal representation, we have no problem, as long as each CHOICE member has a distinct discriminator value. For decoding, we need a way to tell the choice fun
ction to look for a specific arm of the table. The function
\par }\pard\plain \s32\qj\li360\ri360\nowidctlpar\tx0\tx959\tx1918\tx2877\tx3836\tx4795\tx5754\tx6713\tx7672\tx8631{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright \f2\fs20\lang2057 {\cs27 
\par void odr_choice_bias(ODR o, int what);
\par }\pard\plain \qj\sb100\sa100\nowidctlpar{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright \fs22\lang2057 {provides this functionality. When called, it leaves a notice for the next call to }{\cs27\f2\fs20 odr_choice()}{
 to be called on the decoding stream }{\cs27\f2\fs20 o}{ that only the }{\cs27\f2\fs20 arm}{ entry with a }{\cs27\f2\fs20 which}{ field equal to }{\cs27\f2\fs20 what}{ should be tried.
\par The most important application (perhaps the only one, really) is in the definition of application-specific EXTERNAL encoders/decoders which will automatically decode an ANY member given the direct or indirect reference.
\par }\pard\plain \s19\qj\sb100\sa100\keepn\nowidctlpar{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\outlinelevel2\adjustright \b\fs36\lang2057 {{\*\bkmkstart ss5_4}{\*\bkmkstart _Toc399132431}5.4 Debugging{\*\bkmkend ss5_4}{\*\bkmkend _Toc399132431}
\par }\pard\plain \qj\sb100\sa100\nowidctlpar{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright \fs22\lang2057 {
The protocol modules are suffering somewhat from a lack of diagnostic tools at the moment. Specifically ways to pretty-print PDUs that aren't recognized by the system. We'll include something 
to this end in a not-too-distant release. In the meantime, what we do when we get packages we don't understand is to compile the ODR module with }{\cs27\f2\fs20 ODR_DEBUG}{
 defined. This causes the module to dump tracing information as it processes data units. With this output and the protocol specification (Z39.50), it is generally fairly easy to see what goes wrong.{\*\bkmkstart comstack}{\*\bkmkstart s6}
{\*\bkmkend comstack}
\par }\pard\plain \s19\qj\sb100\sa100\keepn\nowidctlpar{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\outlinelevel2\adjustright \b\fs36\lang2057 {{\*\bkmkstart _Toc399132432}6. The COMSTACK Module{\*\bkmkend s6}{\*\bkmkend _Toc399132432}
\par {\*\bkmkstart ss6_1}{\*\bkmkstart _Toc399132433}6.1 Introduction{\*\bkmkend ss6_1}{\*\bkmkend _Toc399132433}
\par }\pard\plain \qj\sb100\sa100\nowidctlpar{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright \fs22\lang2057 {The }{\b COMSTACK}{
 subsystem provides a transparent interface to different types of transport stacks for the exchange of BER-encoded data. At present, the RFC1729 method (BER over TCP/IP), and Peter Furniss' XTImOSI stack are supported, but others may be added in time. The
 philosophy of the module is to provide a simple interface by hiding unused options and facilities of the underlying libraries. This is always done at the risk of losing generality, and it may prove that the interface will need extension later on.
\par The interface is implemented in such a fashion that only the sub-layers constructed to the transport methods that you wish to use in your application are linked in.
\par You will note that even though simplicity was a goal in the design, the interface is still orders of
 magnitudes more complex than the transport systems found in many other packages. One reason is that the interface needs to support the somewhat different requirements of the different lower-layer communications stacks; another important reason is that th
e
 interface seeks to provide a more or less industrial-strength approach to asynchronous event-handling. When no function is allowed to block, things get more complex - particularly on the server side. We urge you to have a look at the demonstration client
 and server provided with the package. They are meant to be easily readable and instructive, while still being at least moderately useful.
\par }\pard\plain \s19\qj\sb100\sa100\keepn\nowidctlpar{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\outlinelevel2\adjustright \b\fs36\lang2057 {{\*\bkmkstart ss6_2}{\*\bkmkstart _Toc399132434}6.2 Common Functions{\*\bkmkend ss6_2}{\*\bkmkend _Toc399132434}

\par }\pard\plain \s20\qj\sb100\sa100\keepn\nowidctlpar{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\outlinelevel3\adjustright \b\fs28\lang2057 {Managing Endpoints
\par }\pard\plain \s32\qj\li360\ri360\nowidctlpar\tx0\tx959\tx1918\tx2877\tx3836\tx4795\tx5754\tx6713\tx7672\tx8631{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright \f2\fs20\lang2057 {\cs27 
\par COMSTACK cs_create(CS_TYPE type, int blocking, int protocol);
\par }\pard\plain \qj\sb100\sa100\nowidctlpar{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright \fs22\lang2057 {Creates an instance of the protocol stack - a communications endpoint. The }{\cs27\f2\fs20 type}{
 parameter determines the mode of communication. At present, the values }{\cs27\f2\fs20 tcpip_type}{ and }{\cs27\f2\fs20 mosi_type}{ are recognized. The function returns a null-pointer if a system error occurs. The }{\cs27\f2\fs20 blocking}{
 parameter should be one if you wish the association to operate in blocking mode, zero otherwise. The }{\cs27\f2\fs20 protocol}{ field should be one of }{\cs27\f2\fs20 PROTO_SR}{ or }{\cs27\f2\fs20 PROTO_Z3950}{.
\par }\pard\plain \s32\qj\li360\ri360\nowidctlpar\tx0\tx959\tx1918\tx2877\tx3836\tx4795\tx5754\tx6713\tx7672\tx8631{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright \f2\fs20\lang2057 {\cs27 
\par int cs_close(COMSTACK handle);
\par }\pard\plain \qj\sb100\sa100\nowidctlpar{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright \fs22\lang2057 {Closes the connection (as elegantly as the lower layers will permit), and releases the resouces pointed to by the }{\cs27\f2\fs20 handle}{
 parameter. The }{\cs27\f2\fs20 handle}{ should not be referenced again after this call.
\par }{\i NOTE: We really need a soft disconnect, don't we?}{
\par }\pard\plain \s20\qj\sb100\sa100\keepn\nowidctlpar{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\outlinelevel3\adjustright \b\fs28\lang2057 {Data Exchange
\par }\pard\plain \s32\qj\li360\ri360\nowidctlpar\tx0\tx959\tx1918\tx2877\tx3836\tx4795\tx5754\tx6713\tx7672\tx8631{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright \f2\fs20\lang2057 {\cs27 
\par int cs_put(COMSTACK handle, char *buf, int len);
\par }\pard\plain \qj\sb100\sa100\nowidctlpar{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright \fs22\lang2057 {Sends }{\cs27\f2\fs20 buf}{
 down the wire. In blocking mode, this function will return only when a full buffer has been written, or an error has occurred. In nonblocking mode, it's possible that the function will be unable to
 send the full buffer at once, which will be indicated by a return value of 1. The function will keep track of the number of octets already written; you should call it repeatedly with the same values of }{\cs27\f2\fs20 buf}{ and }{\cs27\f2\fs20 len}{
, until the buffer has been transmitted. When a full buffer has been sent, the function will return 0 for success. -1 indicates an error condition (see below).
\par }\pard\plain \s32\qj\li360\ri360\nowidctlpar\tx0\tx959\tx1918\tx2877\tx3836\tx4795\tx5754\tx6713\tx7672\tx8631{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright \f2\fs20\lang2057 {\cs27 
\par int cs_get(COMSTACK handle, char **buf, int *size);
\par }\pard\plain \qj\sb100\sa100\nowidctlpar{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright \fs22\lang2057 {Receives a PDU from the peer. Returns the number of bytes read. In nonblocking mode, 
it is possible that not all of the packet can be read at once. In this case, the function returns 1. To simplify the interface, the function is responsible for managing the size of the buffer. It will be reallocated if necessary to contain large packages,
 and will sometimes be moved around internally by the subsystem when partial packages are read. Before calling }{\cs27\f2\fs20 cs_get}{
 for the fist time, the buffer can be initialized to the null pointer, and the length should also be set to 0 - cs_get will perform a }{\cs27\f2\fs20 malloc}{
(2) on the buffer for you. When a full buffer has been read, the size of the package is returned (which will always be greater than 1). -1 indicates an error condition.
\par See also the }{\cs27\f2\fs20 cs_more()}{ function below.
\par }\pard\plain \s32\qj\li360\ri360\nowidctlpar\tx0\tx959\tx1918\tx2877\tx3836\tx4795\tx5754\tx6713\tx7672\tx8631{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright \f2\fs20\lang2057 {\cs27 
\par int cs_more(COMSTACK handle);
\par }\pard\plain \qj\sb100\sa100\nowidctlpar{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright \fs22\lang2057 {The }{\cs27\f2\fs20 cs_more()}{ function should be used in conjunction with }{\cs27\f2\fs20 cs_get}{ and }{\cs27\f2\fs20 select}{(2). The }{
\cs27\f2\fs20 cs_get()}{ function will sometimes (notably in the TCP/IP mode) read more than a single protocol package off the network. When this happens, the extra package is stored by the subsystem. After calling }{\cs27\f2\fs20 cs_get()}{
, and before waiting for more input, You should always call }{\cs27\f2\fs20 cs_more()}{ to check if there's a full protocol package already read. If }{\cs27\f2\fs20 cs_more()}{ returns 1, }{\cs27\f2\fs20 cs_get()}{
 can be used to immediately fetch the new package. For the mOSI subsystem, the function should always return 0, but if you want your stuff to be protocol independent, you should use it.
\par }{\i NOTE: The }{\cs27\i\f2\fs20 cs_more()}{\i  function is required because the RFC1729-method does not provide a way of separating individual PDUs, short of partially decodin
g the BER. Some other implementations will carefully nibble at the packet by calling }{\cs27\i\f2\fs20 read}{\i (2) several times. This was felt to be too inefficient (or at least clumsy) - hence the call for this extra function.}{
\par }\pard\plain \s32\qj\li360\ri360\nowidctlpar\tx0\tx959\tx1918\tx2877\tx3836\tx4795\tx5754\tx6713\tx7672\tx8631{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright \f2\fs20\lang2057 {\cs27 
\par int cs_look(COMSTACK handle);
\par }\pard\plain \qj\sb100\sa100\nowidctlpar{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright \fs22\lang2057 {This function is useful when you're operating in nonblocking mode. Call it when }{\cs27\f2\fs20 select}{
(2) tells you there's something happening on the line. It returns one of the following values:
\par }\pard\plain \s15\qj\sb100\sa100\nowidctlpar{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright \fs22\lang2057 {\b CS_NONE}{
\par }\pard\plain \s16\qj\li360\sb100\sa100\nowidctlpar{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright \fs22\lang2057 {No event is pending. The data found on the line was not a complete package.
\par }\pard\plain \s15\qj\sb100\sa100\nowidctlpar{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright \fs22\lang2057 {\b CS_CONNECT}{
\par }\pard\plain \s16\qj\li360\sb100\sa100\nowidctlpar{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright \fs22\lang2057 {A response to your connect request has been received. Call }{\cs27\f2\fs20 cs_rcvconnect}{
 to process the event and to finalize the connection establishment.
\par }\pard\plain \s15\qj\sb100\sa100\nowidctlpar{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright \fs22\lang2057 {\b CS_DISCON}{
\par }\pard\plain \s16\qj\li360\sb100\sa100\nowidctlpar{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright \fs22\lang2057 {The other side has closed the connection (or maybe sent a disconnect request - but do we care? Maybe later). Call }{\cs27\f2\fs20 
cs_close}{ To close your end of the association as well.
\par }\pard\plain \s15\qj\sb100\sa100\nowidctlpar{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright \fs22\lang2057 {\b CS_LISTEN}{
\par }\pard\plain \s16\qj\li360\sb100\sa100\nowidctlpar{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright \fs22\lang2057 {A connect request has been received. Call }{\cs27\f2\fs20 cs_listen}{ to process the event.
\par }\pard\plain \s15\qj\sb100\sa100\nowidctlpar{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright \fs22\lang2057 {\b CS_DATA}{
\par }\pard\plain \s16\qj\li360\sb100\sa100\nowidctlpar{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright \fs22\lang2057 {There's data to be found on the line. Call }{\cs27\f2\fs20 cs_get}{ to get it.
\par }\pard\plain \qj\sb100\sa100\nowidctlpar{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright \fs22\lang2057 {\i NOTE: You should be aware that even if }{\cs27\i\f2\fs20 cs_look()}{\i 
 tells you that there's an event event pending, the corresponding function may still return and tell you there was nothing to be found. This means that only part of a package was available for reading. The same event will show u
p again, when more data has arrived.}{
\par }\pard\plain \s32\qj\li360\ri360\nowidctlpar\tx0\tx959\tx1918\tx2877\tx3836\tx4795\tx5754\tx6713\tx7672\tx8631{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright \f2\fs20\lang2057 {\cs27 
\par int cs_fileno(COMSTACK h);
\par }\pard\plain \qj\sb100\sa100\nowidctlpar{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright \fs22\lang2057 {Returns the file descriptor of the association. Use this when file-level operations on the endpoint are required (}{\cs27\f2\fs20 select}{
(2) operations, specifically).
\par }\pard\plain \s19\qj\sb100\sa100\keepn\nowidctlpar{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\outlinelevel2\adjustright \b\fs36\lang2057 {{\*\bkmkstart ss6_3}{\*\bkmkstart _Toc399132435}6.3 Client Side{\*\bkmkend ss6_3}{\*\bkmkend _Toc399132435}
\par }\pard\plain \s32\qj\li360\ri360\nowidctlpar\tx0\tx959\tx1918\tx2877\tx3836\tx4795\tx5754\tx6713\tx7672\tx8631{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright \f2\fs20\lang2057 {\cs27 
\par int cs_connect(COMSTACK handle, void *address);
\par }\pard\plain \qj\sb100\sa100\nowidctlpar{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright \fs22\lang2057 {Initiate a connection with the target at }{\cs27\f2\fs20 address}{
 (more on addresses below). The function will return 0 on success, and 1 if the operation does not complete immediately (this will only happen on a nonblocking endpoint). In this case, use }{\cs27\f2\fs20 cs_rcvconnect}{ to complete the operation, when }{
\cs27\f2\fs20 select}{(2) reports input pending on the association.
\par }\pard\plain \s32\qj\li360\ri360\nowidctlpar\tx0\tx959\tx1918\tx2877\tx3836\tx4795\tx5754\tx6713\tx7672\tx8631{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright \f2\fs20\lang2057 {\cs27 
\par int cs_rcvconnect(COMSTACK handle);
\par }\pard\plain \qj\sb100\sa100\nowidctlpar{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright \fs22\lang2057 {Complete a connect operation initiated by }{\cs27\f2\fs20 cs_connect()}{. It will return 0 on suc
cess; 1 if the operation has not yet completed (in this case, call the function again later); -1 if an error has occured.
\par }\pard\plain \s19\qj\sb100\sa100\keepn\nowidctlpar{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\outlinelevel2\adjustright \b\fs36\lang2057 {{\*\bkmkstart ss6_4}{\*\bkmkstart _Toc399132436}6.4 Server Side{\*\bkmkend ss6_4}{\*\bkmkend _Toc399132436}
\par }\pard\plain \qj\sb100\sa100\nowidctlpar{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright \fs22\lang2057 {To establish a server under the }{\cs27\f2\fs20 inetd}{ server, you can use
\par }\pard\plain \s32\qj\li360\ri360\nowidctlpar\tx0\tx959\tx1918\tx2877\tx3836\tx4795\tx5754\tx6713\tx7672\tx8631{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright \f2\fs20\lang2057 {\cs27 
\par COMSTACK cs_createbysocket(int socket, CS_TYPE type, int blocking,
\par                               int protocol);
\par }\pard\plain \qj\sb100\sa100\nowidctlpar{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright \fs22\lang2057 {The }{\i socket}{ parameter is an established socket (when your application is invoked from }{\cs27\f2\fs20 inetd}{
, the socket will typically be 0. The following parameters are identical to the ones for }{\cs27\f2\fs20 cs_create}{.
\par }\pard\plain \s32\qj\li360\ri360\nowidctlpar\tx0\tx959\tx1918\tx2877\tx3836\tx4795\tx5754\tx6713\tx7672\tx8631{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright \f2\fs20\lang2057 {\cs27 
\par int cs_bind(COMSTACK handle, void *address, int mode)
\par }\pard\plain \qj\sb100\sa100\nowidctlpar{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright \fs22\lang2057 {Binds a local address to the endpoint. Read about addresses below. The }{\cs27\f2\fs20 mode}{ parameter should be either }{\cs27\f2\fs20 
CS_CLIENT}{ or }{\cs27\f2\fs20 CS_SERVER}{.
\par }\pard\plain \s32\qj\li360\ri360\nowidctlpar\tx0\tx959\tx1918\tx2877\tx3836\tx4795\tx5754\tx6713\tx7672\tx8631{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright \f2\fs20\lang2057 {\cs27 
\par int cs_listen(COMSTACK handle, char *addr, int *addrlen);
\par }\pard\plain \qj\sb100\sa100\nowidctlpar{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright \fs22\lang2057 {
Call this to process incoming events on an endpoint that has been bound in listening mode. It will return 0 to indicate that the connect request has been received, 1 to signal a partial reception, and -1 to indicate an error condition.
\par }\pard\plain \s32\qj\li360\ri360\nowidctlpar\tx0\tx959\tx1918\tx2877\tx3836\tx4795\tx5754\tx6713\tx7672\tx8631{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright \f2\fs20\lang2057 {\cs27 
\par COMSTACK cs_accept(COMSTACK handle);
\par }\pard\plain \qj\sb100\sa100\nowidctlpar{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright \fs22\lang2057 {
This finalises the server-side association establishment, after cs_listen has completed successfully. It returns a new connection endpoint, which represe
nts the new association. The application will typically wish to fork off a process to handle the association at this point, and continue listen for new connections on the old }{\cs27\f2\fs20 handle}{.
\par You can use the call
\par }\pard\plain \s32\qj\li360\ri360\nowidctlpar\tx0\tx959\tx1918\tx2877\tx3836\tx4795\tx5754\tx6713\tx7672\tx8631{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright \f2\fs20\lang2057 {\cs27 
\par char *cs_addrstr(COMSTACK);
\par }\pard\plain \qj\sb100\sa100\nowidctlpar{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright \fs22\lang2057 {on an established connection to retrieve the hostname of the remote host.
\par }{\i NOTE: You may need to use this function with some care if your name server service is slow or unreliable}{
\par }\pard\plain \s19\qj\sb100\sa100\keepn\nowidctlpar{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\outlinelevel2\adjustright \b\fs36\lang2057 {{\*\bkmkstart ss6_5}{\*\bkmkstart _Toc399132437}6.5 Addresses{\*\bkmkend ss6_5}{\*\bkmkend _Toc399132437}
\par }\pard\plain \qj\sb100\sa100\nowidctlpar{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright \fs22\lang2057 {The low-level format of the addresses are differen
t depending on the mode of communication you have chosen. A function is provided by each of the lower layers to map a user-friendly string-form address to the binary form required by the lower layers.
\par }\pard\plain \s32\qj\li360\ri360\nowidctlpar\tx0\tx959\tx1918\tx2877\tx3836\tx4795\tx5754\tx6713\tx7672\tx8631{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright \f2\fs20\lang2057 {\cs27 
\par struct sockaddr_in *tcpip_strtoaddr(char *str);
\par 
\par struct netbuf *mosi_strtoaddr(char *str);
\par }\pard\plain \qj\sb100\sa100\nowidctlpar{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright \fs22\lang2057 {The format for TCP/IP addresses is straightforward:
\par }\pard\plain \s32\qj\li360\ri360\nowidctlpar\tx0\tx959\tx1918\tx2877\tx3836\tx4795\tx5754\tx6713\tx7672\tx8631{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright \f2\fs20\lang2057 {\cs27 
\par <host> [ ':' <portnum> ]
\par }\pard\plain \qj\sb100\sa100\nowidctlpar{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright \fs22\lang2057 {The }{\cs27\f2\fs20 hostname}{ can be either a domain name or an IP address. The port number, if omitted, defaults to 210.
\par For OSI, the format is
\par }\pard\plain \s32\qj\li360\ri360\nowidctlpar\tx0\tx959\tx1918\tx2877\tx3836\tx4795\tx5754\tx6713\tx7672\tx8631{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright \f2\fs20\lang2057 {\cs27 
\par [ <t-selector> '/' ] <host> [ ':' <port> ]
\par }\pard\plain \qj\sb100\sa100\nowidctlpar{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright \fs22\lang2057 {The transport selector is given as an even number of hex digits.
\par You'll note that the address format for the OSI mode are just a subset of full presentation addresses. We use presentation addresses because xtimosi
 doesn't, in itself, allow access to the X.500 Directory service. We use a limited form, because we haven't yet come across an implementation that used more of the elements of a full p-address. It is a fairly simple matter to add the rest of the elements 
to the address format as needed, however: Xtimosi }{\i does}{ support the full P-address structure.
\par In both transport modes, the special hostname "@" is mapped to any local address (the manifest constant INADDR_ANY). It is used to establish local listening endpoints in the server role.
\par When a connection has been established, you can use
\par }\pard\plain \s32\qj\li360\ri360\nowidctlpar\tx0\tx959\tx1918\tx2877\tx3836\tx4795\tx5754\tx6713\tx7672\tx8631{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright \f2\fs20\lang2057 {\cs27 
\par char cs_addrstr(COMSTACK h);
\par }\pard\plain \qj\sb100\sa100\nowidctlpar{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright \fs22\lang2057 {
to retrieve the host name of the peer system. The function returns a pointer to a static area, which is overwritten on the next call to the function.
\par }{\i N
OTE: We have left the issue of X.500 name-to-address mapping open, for the moment. It would be a simple matter to provide a table-based mapping, if desired. Alternately, we could use the X.500 client-function that is provided with the ISODE (although this
 
would defeat some of the purpose of using ThinOSI in the first place. We have been told that it should be within the realm of the possible to implement a lightweight implementation of the necessary X.500 client capabilities on top of ThinOSI. This would b
e the ideal solution, we feel. On the other hand, it still remains to be seen just what role the Directory will play in a world populated by ThinOSI and other pragmatic solutions.}{
\par }\pard\plain \s19\qj\sb100\sa100\keepn\nowidctlpar{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\outlinelevel2\adjustright \b\fs36\lang2057 {{\*\bkmkstart ss6_6}{\*\bkmkstart _Toc399132438}6.6 Diagnostics{\*\bkmkend ss6_6}{\*\bkmkend _Toc399132438}
\par }\pard\plain \qj\sb100\sa100\nowidctlpar{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright \fs22\lang2057 {All functions return -1 if an error occurs. Typically, the functions will return 0 on success, but the data exchange functions (}{
\cs27\f2\fs20 cs_get}{, }{\cs27\f2\fs20 cs_put}{, }{\cs27\f2\fs20 cs_more}{) follow special rules. Consult their descriptions.
\par When a function (including the data exchange functions) reports an error condition, use the function }{\cs27\f2\fs20 cs_errno()}{ to determine the cause of the problem. The function
\par }\pard\plain \s32\qj\li360\ri360\nowidctlpar\tx0\tx959\tx1918\tx2877\tx3836\tx4795\tx5754\tx6713\tx7672\tx8631{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright \f2\fs20\lang2057 {\cs27 
\par void cs_perror(COMSTACK handle char *message);
\par }\pard\plain \qj\sb100\sa100\nowidctlpar{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright \fs22\lang2057 {works like }{\cs27\f2\fs20 perror}{(2) and prints the }{\cs27\f2\fs20 message}{ argument, along with a system message, to }{\cs27\f2\fs20 
stderr}{. Use the character array
\par }\pard\plain \s32\qj\li360\ri360\nowidctlpar\tx0\tx959\tx1918\tx2877\tx3836\tx4795\tx5754\tx6713\tx7672\tx8631{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright \f2\fs20\lang2057 {\cs27 
\par extern const char *cs_errlist[];
\par }\pard\plain \qj\sb100\sa100\nowidctlpar{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright \fs22\lang2057 {to get hold of the message, if you want to process it differently. The function
\par }\pard\plain \s32\qj\li360\ri360\nowidctlpar\tx0\tx959\tx1918\tx2877\tx3836\tx4795\tx5754\tx6713\tx7672\tx8631{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright \f2\fs20\lang2057 {\cs27 
\par const char *cs_stackerr(COMSTACK handle);
\par }\pard\plain \qj\sb100\sa100\nowidctlpar{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright \fs22\lang2057 {Returns an error message from the lower layer, if one has been provided.
\par }\pard\plain \s19\qj\sb100\sa100\keepn\nowidctlpar{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\outlinelevel2\adjustright \b\fs36\lang2057 {{\*\bkmkstart ss6_7}{\*\bkmkstart _Toc399132439}6.7 Enabling OSI Communication{\*\bkmkend ss6_7}
{\*\bkmkend _Toc399132439}
\par }\pard\plain \s20\qj\sb100\sa100\keepn\nowidctlpar{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\outlinelevel3\adjustright \b\fs28\lang2057 {Installing Xtimosi
\par }\pard\plain \qj\sb100\sa100\nowidctlpar{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright \fs22\lang2057 {
Although you will have to download Peter Furniss' XTI/mOSI implementation for yourself, we've tried to make the integration as simple as possible.
\par The latest version of xtimosi will generally be under
\par }\pard\plain \s32\qj\li360\ri360\nowidctlpar\tx0\tx959\tx1918\tx2877\tx3836\tx4795\tx5754\tx6713\tx7672\tx8631{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright \f2\fs20\lang2057 {\cs27 
\par ftp://pluto.ulcc.ac.uk/ulcc/thinosi/xtimosi/
\par }\pard\plain \qj\sb100\sa100\nowidctlpar{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright \fs22\lang2057 {When you have downloaded and unpacked the archive, it will (we assume) have created a directory called }{\cs27\f2\fs20 xtimosi}{
. We suggest that you place this directory }{\i in the same directory}{ where you unpacked the }{\b YAZ}{ distribution. This way, you shouldn't have to fiddle with the makefiles of }{\cs27\f2\fs20 YAZ}{ beyond uncommenting a few lines.
\par Go to }{\cs27\f2\fs20 xtimosi/src}{, and type "}{\cs27\f2\fs20 make libmosi.a}{". This should generally create the library, ready to use.
\par }{\b CAVEAT}{
\par }{\i 
The currently available release of xtimosi has some inherent problems that make it disfunction on certain platforms - eg. the Digital OSF/1 workstations. It is supposedly primarily a compiler problem, and we hope to see a release that is generally portabl
e. While we can't guarantee that it can be brought to work on your platform, we'll be happy to talk to you about problems that you might see, and relay information to the author of the software. There are some signs that the }{\b\i gcc}{\i 
 compiler is more likely to produce a fully functional library, but this hasn't been verified (we think that the problem is limited to the use of hexadecimal escape-codes used in strings, which are silently ignored by some compilers).}{
\par }{\i A problem has been encountered in the communication with ISODE-based applications. If the ISODE presentation-user calls }{\cs27\i\f2\fs20 PReadRequest()}{\i  with a timeout value different from }{\cs27\i\f2\fs20 OK}{\i  or }{\cs27\i\f2\fs20 NOTOK}{
\i , he will get an immediate TIMEOUT abort when receiving large (>2041 bytes, which is the SPDU-size that the ISODE likes to w
ork with) packages from an xtimosi-based implementation (probably most other implementations as well, in fact). It seems to be a flaw in the ISODE API, and the workaround (for ISODE users) is to either not use an explicit timeout (switching to either bloc
king or nonblocking mode), or to check that the timer really has expired before closing the connection.}{
\par The next step in the installation is to modify the makefile in the toplevel }{\b YAZ}{ directory. The place to change is in the top of the file, and is clearly marked with a comment.
\par Now run }{\cs27\f2\fs20 make}{ in the }{\b YAZ}{ toplevel directory (do a "}{\cs27\f2\fs20 make clean}{" first, if the system has been previously made without OSI support). Use the }{\b YAZ}{ }{\b ztest}{ and }{\b client}{
 demo programs to verify that OSI communication works OK. Then, you can go ahead and try to talk to other implementations.
\par }{\i NOTE: Our interoperability experience is limited to version 7 of the Nordic SR-Nett package, which has had several protocol errors fi
xed from the earlier releases. If you have problems or successes in interoperating with other implementations, we'd be glad to hear about it, or to help you make things work, as our resources allow.}{
\par If you write your own applications based on }{\b YAZ}{, and you wish to include OSI support, the procedure is equally simple. You should include the }{\cs27\f2\fs20 xmosi.h}{ header file in addition to }{\cs27\f2\fs20 comstack.h}{. }{\cs27\f2\fs20 xmosi.h
}{ will define the manifest constant }{\cs27\f2\fs20 mosi_type}{, which you should pass to the }{\cs27\f2\fs20 cs_create()}{ function. In addition, you should use the function }{\cs27\f2\fs20 mosi_strtoaddr()}{ rather than }{\cs27\f2\fs20 
tcpip_strtoaddr()}{ when you need to prepare an address.
\par When you link your application, you should include (after the }{\cs27\f2\fs20 libyaz.a}{ library) the }{\cs27\f2\fs20 libmosi.a}{ library, and the }{\cs27\f2\fs20 librfc.a}{ library provided with }{\b YAZ}{ (for OSI transport).
\par As always, it can be very useful, if not essential, to have a look at the example applications to see how things are done.
\par }\pard\plain \s20\qj\sb100\sa100\keepn\nowidctlpar{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\outlinelevel3\adjustright \b\fs28\lang2057 {OSI Transport
\par }\pard\plain \qj\sb100\sa100\nowidctlpar{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright \fs22\lang2057 {Xtimosi requires an implementation of the OSI transport service under the X/OPEN XTI API. We provide an
 implementation of the RFC1006 encapsulation of OSI/TP0 in TCP/IP (through the Berkeley Sockets API), as an independent part of }{\b YAZ}{ (it's found under the }{\cs27\f2\fs20 rfc1006}{
 directory). If you have access to an OSI transport provider under XTI, you should be able to make that work too, although it may require tinkering with the }{\cs27\f2\fs20 mosi_strtoaddr()}{ function.
\par }\pard\plain \s20\qj\sb100\sa100\keepn\nowidctlpar{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\outlinelevel3\adjustright \b\fs28\lang2057 {Presentation Context Management
\par }\pard\plain \qj\sb100\sa100\nowidctlpar{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright \fs22\lang2057 {To simplify the implementation, we use Peter Furniss' alternative (PRF) option format for the Control of the presentation negotiation p
hase. This format is enabled by default when you compile xtimosi.
\par The current version of }{\b YAZ}{ does }{\i not}{ support presentation-layer negotiation of response record formats. The primary reason is that we have had access to no other SR or Z39.50 implementations 
over OSI that used this method. Secondarily, we believe that the EXPLAIN facility is a superior mechanism for relaying target capabilities in this respect. This is not to say that we have no intentions of supporting presentation context negotiation - we h
ave just hitherto given it a lower priority than other aspects of the protocol.
\par One thing is certain: The addition of this capability to }{\b YAZ}{ should have only a minimal impact on existing applications, and on the interface to the software in general. Most li
kely, we will add an extra layer of interface to the processing of EXPLAIN records, which will convert back and forth between }{\cs27\f2\fs20 oident}{ records (see section }{\field{\*\fldinst {HYPERLINK "yaz-3.html" \\l "oid"}{\fs20 {\*\datafield 
08d0c9ea79f9bace118c8200aa004ba90b02000000090000000303000000000000c00000000000004600000b00000079617a2d332e68746d6c00ffffadde000000000000000000000000000000000000000000000000040000006f006900640000000000}}}{\fldrslt {\cs29\ul\cf2 Object Identifiers}}}{
) and direct or indirect references, given the current association setup. Implementations based on any of the higher-level interfaces will most likely not have to be changed at all.
\par }\pard\plain \s19\qj\sb100\sa100\keepn\nowidctlpar{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\outlinelevel2\adjustright \b\fs36\lang2057 {{\*\bkmkstart ss6_8}{\*\bkmkstart _Toc399132440}6.8 Summary and Synopsis{\*\bkmkend ss6_8}{\*\bkmkend _Toc399132440}

\par }\pard\plain \s32\qj\li360\ri360\nowidctlpar\tx0\tx959\tx1918\tx2877\tx3836\tx4795\tx5754\tx6713\tx7672\tx8631{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright \f2\fs20\lang2057 {\cs27 
\par #include <comstack.h>
\par 
\par #include <tcpip.h>      /* this is for TCP/IP support   */
\par #include <xmosi.h>      /* and this is for mOSI support */
\par 
\par COMSTACK cs_create(CS_TYPE type, int blocking, int protocol);
\par 
\par COMSTACK cs_createbysocket(int s, CS_TYPE type, int blocking,
\par                               int protocol);
\par 
\par int cs_bind(COMSTACK handle, int mode);
\par 
\par int cs_connect(COMSTACK handle, void *address);
\par 
\par int cs_rcvconnect(COMSTACK handle);
\par 
\par int cs_listen(COMSTACK handle);
\par 
\par COMSTACK cs_accept(COMSTACK handle);
\par 
\par int cs_put(COMSTACK handle, char *buf, int len);
\par 
\par int cs_get(COMSTACK handle, char **buf, int *size);
\par 
\par int cs_more(COMSTACK handle);
\par 
\par int cs_close(COMSTACK handle);
\par 
\par int cs_look(COMSTACK handle);
\par 
\par struct sockaddr_in *tcpip_strtoaddr(char *str);
\par 
\par struct netbuf *mosi_strtoaddr(char *str);
\par 
\par extern int cs_errno;
\par 
\par void cs_perror(COMSTACK handle char *message);
\par 
\par const char *cs_stackerr(COMSTACK handle);
\par 
\par extern const char *cs_errlist[];
\par }\pard\plain \s19\qj\sb100\sa100\keepn\nowidctlpar{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\outlinelevel2\adjustright \b\fs36\lang2057 {{\*\bkmkstart server}{\*\bkmkstart s7}{\*\bkmkend server}
\par {\*\bkmkstart _Toc399132441}7. Making an IR Interface for Your Database with YAZ{\*\bkmkend s7}{\*\bkmkend _Toc399132441}
\par {\*\bkmkstart ss7_1}{\*\bkmkstart _Toc399132442}7.1 Introduction{\*\bkmkend ss7_1}{\*\bkmkend _Toc399132442}
\par }\pard\plain \qj\sb100\sa100\nowidctlpar{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright \fs22\lang2057 {\i 
NOTE: If you aren't into documentation, a good way to learn how the backend interface works is to look at the backend.h file. Then, look at the small dummy-server in server/ztest.c. Finally, you can have a look at the seshigh.c file, which is
 where most of the logic of the frontend server is located. The backend.h file also makes a good reference, once you've chewed your way through the prose of this file.}{
\par If you have a database system that you would like to make available by means of Z39.50/SR, }{\b YAZ}{ basically offers your two options. You can use the APIs provided by the }{\b ASN}{, }{\b ODR}{, and }{\b COMSTACK}{
 modules to create and decode PDUs, and exchange them with a client. Using this low-level interface gives you access to all fields and options of the proto
col, and you can construct your server as close to your existing database as you like. It is also a fairly involved process, requiring you to set up an event-handling mechanism, protocol state machine, etc. To simplify server implementation, we have imple
mented a compact and simple, but reasonably full-functioned server-frontend that will handle most of the protocol mechanics, while leaving you to concentrate on your database interface.
\par }{\i NOTE: The backend interface was designed in anticipation of a specific 
integration task, while still attempting to achieve some degree of generality. We realise fully that there are points where the interface can be improved significantly. If you have specific functions or parameters that you think could be useful, send us a
 mail (or better, sign on to the mailing list referred to in the toplevel README file). We will try to fit good suggestions into future releases, to the extent that it can be done without requiring too many structural changes in existing applications.}{

\par }\pard\plain \s19\qj\sb100\sa100\keepn\nowidctlpar{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\outlinelevel2\adjustright \b\fs36\lang2057 {{\*\bkmkstart ss7_2}{\*\bkmkstart _Toc399132443}7.2 The Database Frontend{\*\bkmkend ss7_2}{\*\bkmkend _Toc399132443}

\par }\pard\plain \qj\sb100\sa100\nowidctlpar{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright \fs22\lang2057 {We refer to this software as a generic database frontend. Your database system is the }{\i backend database}{
, and the interface between the two is called the }{\i backend API}{. The backend API consists of a small number of function prototypes and structure definitions. You are required to provide the }{\b main()}{
 routine for the server (which can be quite simple), as well as functions to match each of the prototypes. The interface functions that you write can use any m
echanism you like to communicate with your database system: You might link the whole thing together with your database application and access it by function calls; you might use IPC to talk to a database server somewhere; or you might link with third-part
y software that handles the communication for you (like a commercial database client library). At any rate, the functions will perform the tasks of:
\par {\pntext\pard\plain\f3\fs22 \loch\af3\dbch\af0\hich\f3 \'b7\tab}}\pard \qj\fi-360\li720\sb100\sa100\nowidctlpar{\*\pn \pnlvlblt\ilvl0\ls3\pnrnot0\pnf3\pnindent360\pnhang{\pntxtb \'b7}}\ls3\adjustright {Initialization. 
\par {\pntext\pard\plain\f3\fs22 \loch\af3\dbch\af0\hich\f3 \'b7\tab}}\pard \qj\fi-360\li720\sb100\sa100\nowidctlpar{\*\pn \pnlvlblt\ilvl0\ls3\pnrnot0\pnf3\pnindent360\pnhang{\pntxtb \'b7}}\ls3\adjustright {Searching. 
\par {\pntext\pard\plain\f3\fs22 \loch\af3\dbch\af0\hich\f3 \'b7\tab}}\pard \qj\fi-360\li720\sb100\sa100\nowidctlpar{\*\pn \pnlvlblt\ilvl0\ls3\pnrnot0\pnf3\pnindent360\pnhang{\pntxtb \'b7}}\ls3\adjustright {Fetching records. 
\par {\pntext\pard\plain\f3\fs22 \loch\af3\dbch\af0\hich\f3 \'b7\tab}}\pard \qj\fi-360\li720\sb100\sa100\nowidctlpar{\*\pn \pnlvlblt\ilvl0\ls3\pnrnot0\pnf3\pnindent360\pnhang{\pntxtb \'b7}}\ls3\adjustright {Scanning the database index (if you wish to impl
ement SCAN). 
\par }\pard \qj\sb100\sa100\nowidctlpar\adjustright {(more functions will be added in time to support as much of Z39.50-1995 as possible).
\par Because the model where pipes or sockets are used to access the backend database is a fairly common one, we have added a mechanism that allows this communic
ation to take place asynchronously. In this mode, the frontend server doesn't have to block while the backend database is processing a request, but can wait for additional PDUs from the client.
\par }\pard\plain \s19\qj\sb100\sa100\keepn\nowidctlpar\outlinelevel2\adjustright \b\fs36\lang2057 {{\*\bkmkstart ss7_3}{\*\bkmkstart _Toc399132444}7.3 The Backend API{\*\bkmkend ss7_3}{\*\bkmkend _Toc399132444}
\par }\pard\plain \qj\sb100\sa100\nowidctlpar\adjustright \fs22\lang2057 {The headers files that you need to use the interface are in the include/ directory. They are called }{\cs27\f2\fs20 statserv.h}{ and }{\cs27\f2\fs20 backend.h}{
. They will include other files from the }{\cs27\f2\fs20 include}{ directory, so you'll probably want to use the -I option of your compiler to tell it where to find the files. When you run }{\cs27\f2\fs20 make}{ in the toplevel }{\b YAZ}{
 directory, everything you need to create your server is put the lib/libyaz.a library. If you want OSI as well, you'll also need to link in the }{\cs27\f2\fs20 libmosi.a}{ library from the xtimosi distribution (see the mosi.txt file), a well as the }{
\cs27\f2\fs20 lib/librfc.a}{ library (to provide OSI transport over RFC1006/TCP).
\par }\pard\plain \s19\qj\sb100\sa100\keepn\nowidctlpar\outlinelevel2\adjustright \b\fs36\lang2057 {{\*\bkmkstart ss7_4}{\*\bkmkstart _Toc399132445}7.4 Your main() Routine{\*\bkmkend ss7_4}{\*\bkmkend _Toc399132445}
\par }\pard\plain \qj\sb100\sa100\nowidctlpar\adjustright \fs22\lang2057 {As mentioned, your }{\b main()}{
 routine can be quite brief. If you want to initialize global parameters, or read global configuration tables, this is the place to do it. At the end of the routine, you should call the function
\par }\pard\plain \s32\qj\li360\ri360\nowidctlpar\tx0\tx959\tx1918\tx2877\tx3836\tx4795\tx5754\tx6713\tx7672\tx8631\adjustright \f2\fs20\lang2057 {\cs27 
\par int statserv_main(int argc, char **argv);
\par }\pard\plain \qj\sb100\sa100\nowidctlpar\adjustright \fs22\lang2057 {\b Statserv_main}{ will establish listening sockets according to the parameters given. When connection requests are received, the event handler will typically }{\b fork()}{
 to handle the new request. If you do use global variables, you should be aware, then, that these cannot be shared
 between associations, unless you explicitly disallow forking by command line parameters (we advise against this for any purposes except debugging, as a crash or hang in the server process will affect all users currently signed on to the server).
\par The server provides a mechanism for controlling some of its behavior without using command-line options. The function
\par }\pard\plain \s32\qj\li360\ri360\nowidctlpar\tx0\tx959\tx1918\tx2877\tx3836\tx4795\tx5754\tx6713\tx7672\tx8631\adjustright \f2\fs20\lang2057 {\cs27 
\par statserv_options_block *statserv_getcontrol(void);
\par }\pard\plain \qj\sb100\sa100\nowidctlpar\adjustright \fs22\lang2057 {Will return a pointer to a }{\cs27\f2\fs20 struct statserv_options_block}{ describing the current default settings of the server. The structure contains these elements:
\par }\pard\plain \s15\qj\sb100\sa100\nowidctlpar\adjustright \fs22\lang2057 {\b int dynamic}{
\par }\pard\plain \s16\qj\li360\sb100\sa100\nowidctlpar\adjustright \fs22\lang2057 {A boolean value, which determines whether the server will fork on each incoming request (TRUE), or not (FALSE). Default is TRUE.
\par }\pard\plain \s15\qj\sb100\sa100\nowidctlpar\adjustright \fs22\lang2057 {\b int loglevel}{
\par }\pard\plain \s16\qj\li360\sb100\sa100\nowidctlpar\adjustright \fs22\lang2057 {Set this by ORing the constants defined in include/log.h.
\par }\pard\plain \s15\qj\sb100\sa100\nowidctlpar\adjustright \fs22\lang2057 {\b char logfile[ODR_MAXNAME+1]}{
\par }\pard\plain \s16\qj\li360\sb100\sa100\nowidctlpar\adjustright \fs22\lang2057 {File for diagnostic output ("": stderr).
\par }\pard\plain \s15\qj\sb100\sa100\nowidctlpar\adjustright \fs22\lang2057 {\b char apdufile[ODR_MAXNAME+1]}{
\par }\pard\plain \s16\qj\li360\sb100\sa100\nowidctlpar\adjustright \fs22\lang2057 {Name of file for logging incoming and outgoing APDUs ("": don't log APDUs, "-": }{\cs27\f2\fs20 stderr}{).
\par }\pard\plain \s15\qj\sb100\sa100\nowidctlpar\adjustright \fs22\lang2057 {\b char default_listen[1024]}{
\par }\pard\plain \s16\qj\li360\sb100\sa100\nowidctlpar\adjustright \fs22\lang2057 {
Same form as the command-line specification of listener address. "": no default listener address. Default is to listen at "tcp:@:9999". You can only specify one default listener address in this fashion.
\par }\pard\plain \s15\qj\sb100\sa100\nowidctlpar\adjustright \fs22\lang2057 {\b enum oid_proto default_proto;}{
\par }\pard\plain \s16\qj\li360\sb100\sa100\nowidctlpar\adjustright \fs22\lang2057 {Either }{\cs27\f2\fs20 PROTO_SR}{ or }{\cs27\f2\fs20 PROTO_Z3950}{. Default is }{\cs27\f2\fs20 PROTO_Z39_50}{.
\par }\pard\plain \s15\qj\sb100\sa100\nowidctlpar\adjustright \fs22\lang2057 {\b int idle_timeout;}{
\par }\pard\plain \s16\qj\li360\sb100\sa100\nowidctlpar\adjustright \fs22\lang2057 {Maximum session idletime, in minutes. Zero indicates no (infinite) timeout. Default is 120 minutes.
\par }\pard\plain \s15\qj\sb100\sa100\nowidctlpar\adjustright \fs22\lang2057 {\b int maxrecordsize;}{
\par }\pard\plain \s16\qj\li360\sb100\sa100\nowidctlpar\adjustright \fs22\lang2057 {Maximum permissible record (message) size. Default is 1Mb. This amount of mem
ory will only be allocated if a client requests a very large amount of records in one operation (or a big record). Set it to a lower number if you are worried about resource consumption on your host system.
\par }\pard\plain \s15\qj\sb100\sa100\nowidctlpar\adjustright \fs22\lang2057 {\b char configname[ODR_MAXNAME+1]}{
\par }\pard\plain \s16\qj\li360\sb100\sa100\nowidctlpar\adjustright \fs22\lang2057 {Passed to the backend when a new connection is received.
\par }\pard\plain \s15\qj\sb100\sa100\nowidctlpar\adjustright \fs22\lang2057 {\b char setuid[ODR_MAXNAME+1]}{
\par }\pard\plain \s16\qj\li360\sb100\sa100\nowidctlpar\adjustright \fs22\lang2057 {Set user id to the user specified, after binding the listener addresses.
\par }\pard\plain \qj\sb100\sa100\nowidctlpar\adjustright \fs22\lang2057 {The pointer returned by }{\cs27\f2\fs20 statserv_getcontrol}{ points to a static area. You are allowed to change the contents of the st
ructure, but the changes will not take effect before you call
\par }\pard\plain \s32\qj\li360\ri360\nowidctlpar\tx0\tx959\tx1918\tx2877\tx3836\tx4795\tx5754\tx6713\tx7672\tx8631\adjustright \f2\fs20\lang2057 {\cs27 
\par void statserv_setcontrol(statserv_options_block *block);
\par }\pard\plain \qj\sb100\sa100\nowidctlpar\adjustright \fs22\lang2057 {Note that you should generally update this structure }{\i before}{ calling }{\cs27\f2\fs20 statserv_main()}{.
\par }\pard\plain \s19\qj\sb100\sa100\keepn\nowidctlpar\outlinelevel2\adjustright \b\fs36\lang2057 {{\*\bkmkstart ss7_5}{\*\bkmkstart _Toc399132446}7.5 The Backend Functions{\*\bkmkend ss7_5}{\*\bkmkend _Toc399132446}
\par }\pard\plain \qj\sb100\sa100\nowidctlpar\adjustright \fs22\lang2057 {
For each service of the protocol, the backend interface declares one or two functions. You are required to provide implementations of the functions representing the services that you wish to implement.
\par }\pard\plain \s32\qj\li360\ri360\nowidctlpar\tx0\tx959\tx1918\tx2877\tx3836\tx4795\tx5754\tx6713\tx7672\tx8631\adjustright \f2\fs20\lang2057 {\cs27 
\par bend_initresult *bend_init(bend_initrequest *r);
\par }\pard\plain \qj\sb100\sa100\nowidctlpar\adjustright \fs22\lang2057 {
This function is called once for each new connection request, after a new process has been forked, and an initRequest has been received from the client. The parameter and result structures are defined as
\par }\pard\plain \s32\qj\li360\ri360\nowidctlpar\tx0\tx959\tx1918\tx2877\tx3836\tx4795\tx5754\tx6713\tx7672\tx8631\adjustright \f2\fs20\lang2057 {\cs27 
\par typedef struct bend_initrequest
\par \{
\par     char *configname;
\par \} bend_initrequest;
\par 
\par typedef struct bend_initresult
\par \{
\par     int errcode;       /* 0==OK */
\par     char *errstring;   /* system error string or NULL */
\par     void *handle;      /* private handle to the backend module */
\par \} bend_initresult;
\par }\pard\plain \qj\sb100\sa100\nowidctlpar\adjustright \fs22\lang2057 {The }{\cs27\f2\fs20 configname}{ of }{\cs27\f2\fs20 bend_initrequest}{
 is currently always set to "default-config". We haven't had use for putting anything special in the initrequest yet, but something might go there if the need arises (account/password info would be obvious).
\par In general, the server frontend expects that the }{\cs27\f2\fs20 bend_*result}{ pointer that you return is valid at least until the next call to a }{\cs27\f2\fs20 bend_* function}{
. This applies to all of the functions described herein. The parameter structure passed to you in
 the call belongs to the server frontend, and you should not make assumptions about its contents after the current function call has completed. In other words, if you want to retain any of the contents of a request structure, you should copy them.
\par The }{\cs27\f2\fs20 errcode}{ should be zero if the initialization of the backend went well. Any other value will be interpreted as an error. The }{\cs27\f2\fs20 errstring}{
 isn't used in the current version, but one option would be to stick it in the initResponse as a VisibleString. The }{\cs27\f2\fs20 handle}{ is t
he most important parameter. It should be set to some value that uniquely identifies the current session to the backend implementation. It is used by the frontend server in any future calls to a backend function. The typical use is to set it to point to a
 dynamically allocated state structure that is private to your backend module.
\par }\pard\plain \s32\qj\li360\ri360\nowidctlpar\tx0\tx959\tx1918\tx2877\tx3836\tx4795\tx5754\tx6713\tx7672\tx8631\adjustright \f2\fs20\lang2057 {\cs27 
\par bend_searchresult *bend_search(void *handle, bend_searchrequest *r,
\par                                int *fd);
\par bend_searchresult *bend_searchresponse(void *handle);
\par 
\par typedef struct bend_searchrequest
\par \{
\par     char *setname;       /* name to give to this set */
\par     int replace_set;     /* replace set, if it already exists */
\par     int num_bases;       /* number of databases in list */
\par     char **basenames;    /* databases to search */
\par     Z_Query *query;      /* query structure */
\par \} bend_searchrequest;
\par 
\par typedef struct bend_searchresult
\par \{
\par     int hits;            /* number of hits */
\par     int errcode;         /* 0==OK */
\par     char *errstring;     /* system error string or NULL */
\par \} bend_searchresult;
\par }\pard\plain \qj\sb100\sa100\nowidctlpar\adjustright \fs22\lang2057 {
The first thing to notice about the search request interface (as well as all of the following requests), is that it consists of two separate functions. The idea is to provide a simple facility for asynchronous communication with the backend ser
ver. When a searchrequest comes in, the server frontend will fill out the }{\cs27\f2\fs20 bend_searchrequest}{ tructure, and call the }{\cs27\f2\fs20 bend_search function}{. The }{\cs27\f2\fs20 fd}{
 argument will point to an integer variable. If you are able to do asynchronous I/O with your database server, you should set *}{\cs27\f2\fs20 fd}{
 to the file descriptor you use for the communication, and return a null pointer. The server frontend will then }{\cs27\f2\fs20 select()}{ on the *}{\cs27\f2\fs20 fd}{, and will call }{\cs27\f2\fs20 bend_searchresult}{
 when it sees that data is available. If you don't support asynchronous I/O, you should return a pointer to the }{\cs27\f2\fs20 bend_searchresult}{ immediately, and leave *}{\cs27\f2\fs20 fd}{ untouched. This construction is common to all of the }{
\cs27\f2\fs20 bend_}{ functions (except }{\cs27\f2\fs20 bend_init}{). Note that you can choose to support this facility in none, any, or all of the }{\cs27\f2\fs20 bend_}{ f
unctions, and you can respond differently on each request at run-time. The server frontend will adapt accordingly.
\par The }{\cs27\f2\fs20 bend_searchrequest}{ is a fairly close approximation of a protocol searchRequest PDU. The }{\cs27\f2\fs20 setname}{ is the resultSetName from the protocol. Y
ou are required to establish a mapping between the set name and whatever your backend database likes to use. Similarly, the }{\cs27\f2\fs20 replace_set}{ is a boolean value corresponding to the resultSetIndicator field in the protocol. }{\cs27\f2\fs20 
Num_bases/basenames}{ is a length of/array of character pointers to the database names provided by the client. The }{\cs27\f2\fs20 query}{
 is the full query structure as defined in the protocol ASN.1 specification. It can be either of the possible query types, and it's up to you to determine if
 you can handle the provided query type. Rather than reproduce the C interface here, we'll refer you to the structure definitions in the file }{\cs27\f2\fs20 include/proto.h}{
. If you want to look at the attributeSetId OID of the RPN query, you can either match it against your own internal tables, or you can use the }{\cs27\f2\fs20 oid_getentbyoid}{ function provided by }{\b YAZ}{.
\par The result structure contains a number of hits, and an }{\cs27\f2\fs20 errcode/errstring}{ pair. If an error occurs during the search, or if you're unhappy with the request, you should set
 the errcode to a value from the BIB-1 diagnostic set. The value will then be returned to the user in a nonsurrogate diagnostic record in the response. The }{\cs27\f2\fs20 errstring}{
, if provided, will go in the addinfo field. Look at the protocol definition for the defined error codes, and the suggested uses of the addinfo field.
\par }\pard\plain \s32\qj\li360\ri360\nowidctlpar\tx0\tx959\tx1918\tx2877\tx3836\tx4795\tx5754\tx6713\tx7672\tx8631\adjustright \f2\fs20\lang2057 {\cs27 
\par bend_fetchresult *bend_fetch(void *handle, bend_fetchrequest *r,
\par                              int *fd);
\par bend_fetchresult *bend_fetchresponse(void *handle);
\par 
\par typedef struct bend_fetchrequest
\par \{
\par     char *setname;       /* set name */
\par     int number;          /* record number */
\par     oid_value format;
\par \} bend_fetchrequest;
\par 
\par typedef struct bend_fetchresult
\par \{
\par     char *basename;      /* name of database that provided record */
\par     int len;             /* length of record */
\par     char *record;        /* record */
\par     int last_in_set;     /* is it?  */
\par     oid_value format;
\par     int errcode;         /* 0==success */
\par     char *errstring;     /* system error string or NULL */
\par \} bend_fetchresult;
\par }\pard\plain \qj\sb100\sa100\nowidctlpar\adjustright \fs22\lang2057 {\i NOTE: The }{\cs27\i\f2\fs20 bend_fetchresponse()}{\i  function is not yet supported in this version of the software. Your implementation of }{\cs27\i\f2\fs20 bend_fetch()}{\i 
 should always return a pointer to a }{\cs27\i\f2\fs20 bend_fetchresult}{\i .}{
\par The frontend server calls }{\cs27\f2\fs20 bend_fetch}{ when it needs database records to fulfill a searchRequest or a presentRequest. The }{\cs27\f2\fs20 setname}{ is simply the name of the result set that holds the reference to the desired record. The }{
\cs27\f2\fs20 number}{ is the offset into the set (with 1 being the first record in the set). The }{\cs27\f2\fs20 format}{ field is the record format requested by the client (See section }{\field{\*\fldinst {HYPERLINK "yaz-3.html" \\l "oid"}{\fs20 
{\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000090000000303000000000000c00000000000004600000b00000079617a2d332e68746d6c00ffffadde000000000000000000000000000000000000000000000000040000006f006900640000000000}}}{\fldrslt {\cs29\ul\cf2 
Object Identifiers}}}{). The value }{\cs27\f2\fs20 VAL_NONE}{ indicates that the client did not request a specific format. The }{\cs27\f2\fs20 stream}{ argument is an }{\b ODR}{ stream which should be used for alloc
ating space for structured data records. The stream will be reset when all records have been assembled, and the response package has been transmitted. For unstructured data, the backend is responsible for maintaining a static or dynamic buffer for the rec
ord between calls.
\par In the result structure, the }{\cs27\f2\fs20 basename}{ is the name of the database that holds the record. }{\cs27\f2\fs20 Len}{ is the length of the record returned, in bytes, and }{\cs27\f2\fs20 record}{ is a pointer to the record. }{\cs27\f2\fs20 
Last_in_set}{ should be nonzero only if the record returned is the last one in the given result set. }{\cs27\f2\fs20 Errcode}{ and }{\cs27\f2\fs20 errstring}{
, if given, will currently be interpreted as a global error pertaining to the set, and will be returned in a nonSurrogateDiagnostic.
\par }{\i NOTE: This is silly. Add a flag to say which is which.}{
\par If the }{\cs27\f2\fs20 len}{ field has the value -1, then }{\cs27\f2\fs20 record}{ is assumed to point to a constructed data type. The }{\cs27\f2\fs20 format}{ field will be used to determine which encoder should be used to serialize the data.
\par }{\i NOTE: If your backend generates structured records, it should use }{\cs27\i\f2\fs20 odr_malloc()}{\i  on the provided stream for allocating data: This allows the frontend server to keep track of the record sizes.}{
\par The }{\cs27\f2\fs20 format}{ field is mapped to an object identifier in the direct reference of the resulting EXTERNAL representation of the record.
\par }{\i NOTE: The current version of }{\b\i YAZ}{\i  only supports the direct reference mode.}{
\par }\pard\plain \s32\qj\li360\ri360\nowidctlpar\tx0\tx959\tx1918\tx2877\tx3836\tx4795\tx5754\tx6713\tx7672\tx8631\adjustright \f2\fs20\lang2057 {\cs27 
\par bend_deleteresult *bend_delete(void *handle, bend_deleterequest *r,
\par                                int *fd);
\par bend_deleteresult *bend_deleteresponse(void *handle);
\par 
\par typedef struct bend_deleterequest
\par \{
\par     char *setname;
\par \} bend_deleterequest;
\par 
\par typedef struct bend_deleteresult
\par \{
\par     int errcode;         /* 0==success */
\par     char *errstring;     /* system error string or NULL */
\par \} bend_deleteresult;
\par }\pard\plain \qj\sb100\sa100\nowidctlpar\adjustright \fs22\lang2057 {\i NOTE: The "delete" function is not yet supported in this version of the software.}{
\par }{\i NOTE: The delete set function definition is rather primitive, mostly because we have had no practical need for it as of yet. If someone wants to provide a full delete service
, we'd be happy to add the extra parameters that are required. Are there clients out there that will actually delete sets they no longer need?}{
\par }\pard\plain \s32\qj\li360\ri360\nowidctlpar\tx0\tx959\tx1918\tx2877\tx3836\tx4795\tx5754\tx6713\tx7672\tx8631\adjustright \f2\fs20\lang2057 {\cs27 
\par bend_scanresult *bend_scan(void *handle, bend_scanrequest *r,
\par     int *fd);
\par bend_scanresult *bend_scanresponse(void *handle);
\par 
\par typedef struct bend_scanrequest
\par \{
\par     int num_bases;      /* number of elements in databaselist */
\par     char **basenames;   /* databases to search */
\par     Z_AttributesPlusTerm *term;
\par     int term_position;  /* desired index of term in result list */
\par     int num_entries;    /* number of entries requested */
\par \} bend_scanrequest;
\par 
\par typedef struct bend_scanresult
\par \{
\par     int num_entries;
\par     struct scan_entry
\par     \{
\par         char *term;
\par         int occurrences;
\par     \} *entries;
\par     int term_position;
\par     enum
\par     \{
\par         BEND_SCAN_SUCCESS,
\par         BEND_SCAN_PARTIAL
\par     \} status;
\par     int errcode;
\par     char *errstring;
\par \} bend_scanresult;
\par }\pard\plain \qj\sb100\sa100\nowidctlpar\adjustright \fs22\lang2057 {\i NOTE: The }{\cs27\i\f2\fs20 bend_scanresponse()}{\i  function is not yet supported in this version of the software. Your implementation of }{\cs27\i\f2\fs20 bend_scan()}{\i 
 should always return a pointer to a }{\cs27\i\f2\fs20 bend_scanresult}{\i .}{
\par }\pard\plain \s19\qj\sb100\sa100\keepn\nowidctlpar\outlinelevel2\adjustright \b\fs36\lang2057 {{\*\bkmkstart ss7_6}{\*\bkmkstart _Toc399132447}7.6 Application Invocation{\*\bkmkend ss7_6}{\*\bkmkend _Toc399132447}
\par }\pard\plain \qj\sb100\sa100\nowidctlpar\adjustright \fs22\lang2057 {The finished application has the following invocation syntax (by way of }{\cs27\f2\fs20 statserv_main()}{):
\par }\pard\plain \s32\qj\li360\ri360\nowidctlpar\tx0\tx959\tx1918\tx2877\tx3836\tx4795\tx5754\tx6713\tx7672\tx8631\adjustright \f2\fs20\lang2057 {\cs27 
\par appname [-szSu -a apdufile -l logfile -v loglevel]
\par [listener ...]
\par }\pard\plain \qj\sb100\sa100\nowidctlpar\adjustright \fs22\lang2057 {The options are
\par }\pard\plain \s15\qj\sb100\sa100\nowidctlpar\adjustright \fs22\lang2057 {\b -a}{
\par }\pard\plain \s16\qj\li360\sb100\sa100\nowidctlpar\adjustright \fs22\lang2057 {APDU file. Specify a file for dumping PDUs (for diagnostic purposes). The special name "-" sends output to }{\cs27\f2\fs20 stderr}{.
\par }\pard\plain \s15\qj\sb100\sa100\nowidctlpar\adjustright \fs22\lang2057 {\b -S}{
\par }\pard\plain \s16\qj\li360\sb100\sa100\nowidctlpar\adjustright \fs22\lang2057 {Do
n't fork on connection requests. This is good for debugging, but not recommended for real operation: Although the server is asynchronous and non-blocking, it can be nice to keep a software malfunction (okay then, a crash) from affecting all current users.

\par }\pard\plain \s15\qj\sb100\sa100\nowidctlpar\adjustright \fs22\lang2057 {\b -s}{
\par }\pard\plain \s16\qj\li360\sb100\sa100\nowidctlpar\adjustright \fs22\lang2057 {Use the SR protocol.
\par }\pard\plain \s15\qj\sb100\sa100\nowidctlpar\adjustright \fs22\lang2057 {\b -z}{
\par }\pard\plain \s16\qj\li360\sb100\sa100\nowidctlpar\adjustright \fs22\lang2057 {
Use the Z39.50 protocol (default). These two options complement eachother. You can use both multiple times on the same command line, between listener-specifications (see below). This way, you can set up the server to listen for c
onnections in both protocols concurrently, on different local ports.
\par }\pard\plain \s15\qj\sb100\sa100\nowidctlpar\adjustright \fs22\lang2057 {\b -l}{
\par }\pard\plain \s16\qj\li360\sb100\sa100\nowidctlpar\adjustright \fs22\lang2057 {The logfile.
\par }\pard\plain \s15\qj\sb100\sa100\nowidctlpar\adjustright \fs22\lang2057 {\b -v}{
\par }\pard\plain \s16\qj\li360\sb100\sa100\nowidctlpar\adjustright \fs22\lang2057 {The log level. Use a comma-separated list of members of the set \{fatal,debug,warn,log,all,none\}.
\par }\pard\plain \s15\qj\sb100\sa100\nowidctlpar\adjustright \fs22\lang2057 {\b -u}{
\par }\pard\plain \s16\qj\li360\sb100\sa100\nowidctlpar\adjustright \fs22\lang2057 {
Set user ID. Sets the real UID of the server process to that of the given user. It's useful if you aren't comfortable with having the server run as root, but you need to start it as such to bind a privileged port.
\par }\pard\plain \s15\qj\sb100\sa100\nowidctlpar\adjustright \fs22\lang2057 {\b -w}{
\par }\pard\plain \s16\qj\li360\sb100\sa100\nowidctlpar\adjustright \fs22\lang2057 {Working directory.
\par }\pard\plain \s15\qj\sb100\sa100\nowidctlpar\adjustright \fs22\lang2057 {\b -i}{
\par }\pard\plain \s16\qj\li360\sb100\sa100\nowidctlpar\adjustright \fs22\lang2057 {Use this when running from the }{\cs27\f2\fs20 inetd}{ server.
\par }\pard\plain \s15\qj\sb100\sa100\nowidctlpar\adjustright \fs22\lang2057 {\b -t}{
\par }\pard\plain \s16\qj\li360\sb100\sa100\nowidctlpar\adjustright \fs22\lang2057 {Idle session timeout, in minutes.
\par }\pard\plain \s15\qj\sb100\sa100\nowidctlpar\adjustright \fs22\lang2057 {\b -k}{
\par }\pard\plain \s16\qj\li360\sb100\sa100\nowidctlpar\adjustright \fs22\lang2057 {Maximum record size/message size, in kilobytes.
\par }\pard\plain \qj\sb100\sa100\nowidctlpar\adjustright \fs22\lang2057 {A listener specification consists of a transport mode followed by a colon (:) followed by a listener address. The transport mode is either }{\cs27\f2\fs20 osi}{ or }{\cs27\f2\fs20 tcp}{.

\par For TCP, an address has the form
\par }\pard\plain \s32\qj\li360\ri360\nowidctlpar\tx0\tx959\tx1918\tx2877\tx3836\tx4795\tx5754\tx6713\tx7672\tx8631\adjustright \f2\fs20\lang2057 {\cs27 
\par hostname | IP-number [: portnumber]
\par }\pard\plain \qj\sb100\sa100\nowidctlpar\adjustright \fs22\lang2057 {The port number defaults to 210 (standard Z39.50 port).
\par For osi, the address form is
\par }\pard\plain \s32\qj\li360\ri360\nowidctlpar\tx0\tx959\tx1918\tx2877\tx3836\tx4795\tx5754\tx6713\tx7672\tx8631\adjustright \f2\fs20\lang2057 {\cs27 
\par [t-selector /] hostname | IP-number [: portnumber]
\par }\pard\plain \qj\sb100\sa100\nowidctlpar\adjustright \fs22\lang2057 {The transport selector is given as a string of hex digits (with an even number of digits). The default port number is 102 (RFC1006 port).
\par Examples
\par }\pard\plain \s32\qj\li360\ri360\nowidctlpar\tx0\tx959\tx1918\tx2877\tx3836\tx4795\tx5754\tx6713\tx7672\tx8631\adjustright \f2\fs20\lang2057 {\cs27 
\par tcp:dranet.dra.com
\par 
\par osi:0402/dbserver.osiworld.com:3000
\par }\pard\plain \qj\sb100\sa100\nowidctlpar\adjustright \fs22\lang2057 {In both cases, the special hostname "@" is mapped to the address INADDR_ANY, which causes 
the server to listen on any local interface. To start the server listening on the registered ports for Z39.50 and SR over OSI/RFC1006, and to drop root privileges once the ports are bound, execute the server like this (from a root shell):
\par }\pard\plain \s32\qj\li360\ri360\nowidctlpar\tx0\tx959\tx1918\tx2877\tx3836\tx4795\tx5754\tx6713\tx7672\tx8631\adjustright \f2\fs20\lang2057 {\cs27 
\par my-server -u daemon tcp:@ -s osi:@
\par }\pard\plain \qj\sb100\sa100\nowidctlpar\adjustright \fs22\lang2057 {You can replace }{\cs27\f2\fs20 daemon}{ with another user, eg. your own account, or a dedicated IR server account. }{\cs27\f2\fs20 my-server}{
 should be the name of your server application. You can test the procedure with the }{\cs27\f2\fs20 ztest}{ application.
\par }\pard\plain \s19\qj\sb100\sa100\keepn\nowidctlpar\outlinelevel2\adjustright \b\fs36\lang2057 {{\*\bkmkstart ss7_7}{\*\bkmkstart _Toc399132448}7.7 Summary and Synopsis{\*\bkmkend ss7_7}{\*\bkmkend _Toc399132448}
\par }\pard\plain \s32\qj\li360\ri360\nowidctlpar\tx0\tx959\tx1918\tx2877\tx3836\tx4795\tx5754\tx6713\tx7672\tx8631\adjustright \f2\fs20\lang2057 {\cs27 
\par #include <backend.h>
\par 
\par bend_initresult *bend_init(bend_initrequest *r);
\par 
\par bend_searchresult *bend_search(void *handle, bend_searchrequest *r,
\par                                  int *fd);
\par 
\par bend_searchresult *bend_searchresponse(void *handle);
\par 
\par bend_fetchresult *bend_fetch(void *handle, bend_fetchrequest *r,
\par                                int *fd);
\par 
\par bend_fetchresult *bend_fetchresponse(void *handle);
\par 
\par bend_scanresult *bend_scan(void *handle, bend_scanrequest *r, int *fd);
\par 
\par bend_scanresult *bend_scanresponse(void *handle);
\par 
\par bend_deleteresult *bend_delete(void *handle, bend_deleterequest *r,
\par                                   int *fd);
\par 
\par bend_deleteresult *bend_deleteresponse(void *handle);
\par 
\par void bend_close(void *handle);
\par }\pard\plain \s19\qj\sb100\sa100\keepn\nowidctlpar\outlinelevel2\adjustright \b\fs36\lang2057 {{\*\bkmkstart s8}
\par {\*\bkmkstart _Toc399132449}8. Future Directions{\*\bkmkend s8}{\*\bkmkend _Toc399132449}
\par }\pard\plain \qj\sb100\sa100\nowidctlpar\adjustright \fs22\lang2057 {The software has been successfully ported to the Mac as well as Windows NT/95 - we'd like to test those ports better and make sure they work as they should.
\par We have a new and better version of the frontend server on the drawing board. Resources and external commitments will govern when we'll be able to do something real with it. Fetures should include greater flexibility, greter support for access/resource co
ntrol, and easy support for Explain (possibly with Zebra as an extra database engine).
\par We now support all PDUs of Z39.50-1995. If there is one of the supporting structures that you need but can't find in the prt*.h files, send us a note; it may be on its way.
\par The 'retrieval' module needs to be finalized and documented. We think it can form a useful resource for people dealing with complex record structures, but for now, you'll mostly have to chew through the code yourself to make use of it. Not acceptable.

\par O
ther than that, YAZ generally moves in the directions which appear to make the most people happy (including ourselves, as prime users of the software). If there's something you'd like to see in here, then drop us a note and let's see what we can come up w
ith.
\par }\pard\plain \s19\qj\sb100\sa100\keepn\nowidctlpar\outlinelevel2\adjustright \b\fs36\lang2057 {{\*\bkmkstart s9}{\*\bkmkstart _Toc399132450}9. License{\*\bkmkend s9}{\*\bkmkend _Toc399132450}
\par {\*\bkmkstart ss9_1}{\*\bkmkstart _Toc399132451}9.1 Index Data Copyright{\*\bkmkend ss9_1}{\*\bkmkend _Toc399132451}
\par }\pard\plain \qj\sb100\sa100\nowidctlpar\adjustright \fs22\lang2057 {Copyright (c) 1995,1996 Index Data.
\par Permission to use, copy, modify, distribute, and sell this software and its documentation, in whole or in part, for any purpose, is hereby granted, provided that:
\par 1. This copyright and permission notice appear in all copies of the software and its documentation. Notices of copyright or attribution which appear at the beginning of any file must remain unchanged.
\par 2. The names of Index Data or the individual authors may not be used to endorse or promote products derived from this software without specific prior written permission.
\par THIS SOFTWARE IS PROVIDED "AS IS" AND WITHOUT WARRANTY OF ANY KIND, EXPRESS, IMPLIED, OR OTH
ERWISE, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL INDEX DATA BE LIABLE FOR ANY SPECIAL, INCIDENTAL, INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY KIND, OR ANY DAMAGES WHATSOEVER RESULTI
NG FROM LOSS OF USE, DATA OR PROFITS, WHETHER OR NOT ADVISED OF THE POSSIBILITY OF DAMAGE, AND ON ANY THEORY OF LIABILITY, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
\par }\pard\plain \s19\qj\sb100\sa100\keepn\nowidctlpar\outlinelevel2\adjustright \b\fs36\lang2057 {{\*\bkmkstart ss9_2}{\*\bkmkstart _Toc399132452}9.2 Additional Copyright Statements{\*\bkmkend ss9_2}{\*\bkmkend _Toc399132452}
\par }\pard\plain \qj\sb100\sa100\nowidctlpar\adjustright \fs22\lang2057 {The optional CCL query language interpreter is covered by the following license:
\par Copyright (c) 1995, the EUROPAGATE consortium (see below).
\par The EUROPAGATE consortium members are:
\par University College Dublin Danmarks Teknologiske Videnscenter An Chomhairle Leabharlanna Consejo Superior de Investigaciones Cientificas
\par Permission to use, copy, modify, distribute, and sell this software and its documentation, in whole or in part, for any purpose, is hereby granted, provided that:
\par 1. This copyright and permission notice appear in all copies of the software and its documentation. Notices of copyright or attribution which appear at the beginning of any file must remain unchanged.
\par 2. The names of EUROPAGATE or the project partners may not be used to endorse or promote products derived from this software without specific prior written permission.
\par 3. Users of this software (implementors and gateway operators) agree to inform the EUROPAGATE consortium of their use of the software. This information will be u
sed to evaluate the EUROPAGATE project and the software, and to plan further developments. The consortium may use the information in later publications.
\par 4. Users of this software agree to make their best efforts, when documenting their use of the software, to acknowledge the EUROPAGATE consortium, and the role played by the software in their work.
\par THIS SOFTWARE IS PROVIDED "AS IS" AND WITHOUT WARRANTY OF ANY KIND, EXPRESS, IMPLIED, OR OTHERWISE, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY 
OR FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL THE EUROPAGATE CONSORTIUM OR ITS MEMBERS BE LIABLE FOR ANY SPECIAL, INCIDENTAL, INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY KIND, OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WH
ETHER OR NOT ADVISED OF THE POSSIBILITY OF DAMAGE, AND ON ANY THEORY OF LIABILITY, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
\par }\pard\plain \s19\qj\sb100\sa100\keepn\nowidctlpar\outlinelevel2\adjustright \b\fs36\lang2057 {{\*\bkmkstart s10}{\*\bkmkstart _Toc399132453}10. About Index Data{\*\bkmkend s10}{\*\bkmkend _Toc399132453}
\par }\pard\plain \qj\sb100\sa100\nowidctlpar\adjustright \fs22\lang2057 {Index Data is a consulting and software-dev
elopment enterprise that specialises in library and information management systems. Our interests and expertise span a broad range of related fields, and one of our primary, long-term objectives is the development of a powerful information management syst
em with open network interfaces and hypermedia capabilities.
\par We make this software available free of charge, on a fairly unrestrictive license; as a service to the networking community, and to further the development of quality software for open network communication.
\par We'll be happy to answer questions about the software, and about ourselves in general.
\par }\pard\plain \s25\qj\li360\ri360\sb100\sa100\nowidctlpar\adjustright \fs22\lang2057 {\cs27\f2\fs20 Index Data\line Ryesgade 3\line DK-2200 K\'f8benhavn N}{
\par }\pard\plain \s32\qj\li360\ri360\nowidctlpar\tx0\tx959\tx1918\tx2877\tx3836\tx4795\tx5754\tx6713\tx7672\tx8631\adjustright \f2\fs20\lang2057 {\cs27 
\par Phone: +45 3536 3672
\par Fax  : +45 3536 0449
\par Email: info@index.ping.dk
\par }\pard\plain \qj\sb100\sa100\nowidctlpar\adjustright \fs22\lang2057 {
\par }}